{"version":3,"sources":["../src/index.ts","../src/client.ts","../src/utils.ts","../src/post.ts","../src/prompts.ts","../src/memory.ts","../src/actions.ts","../src/interactions.ts","../src/providers/StorjProvider.ts"],"sourcesContent":["import { Client, IAgentRuntime, elizaLogger } from \"@ai16z/eliza\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { LensClient } from \"./client\";\nimport { LensPostManager } from \"./post\";\nimport { LensInteractionManager } from \"./interactions\";\nimport StorjProvider from \"./providers/StorjProvider\";\n\nexport class LensAgentClient implements Client {\n    client: LensClient;\n    posts: LensPostManager;\n    interactions: LensInteractionManager;\n\n    private profileId: `0x${string}`;\n    private ipfs: StorjProvider;\n\n    constructor(public runtime: IAgentRuntime) {\n        const cache = new Map<string, any>();\n\n        const privateKey = runtime.getSetting(\n            \"EVM_PRIVATE_KEY\"\n        ) as `0x${string}`;\n        if (!privateKey) {\n            throw new Error(\"EVM_PRIVATE_KEY is missing\");\n        }\n        const account = privateKeyToAccount(privateKey);\n\n        this.profileId = runtime.getSetting(\n            \"LENS_PROFILE_ID\"\n        )! as `0x${string}`;\n\n        this.client = new LensClient({\n            runtime: this.runtime,\n            account,\n            cache,\n            profileId: this.profileId,\n        });\n\n        elizaLogger.info(\"Lens client initialized.\");\n\n        this.ipfs = new StorjProvider(runtime);\n\n        this.posts = new LensPostManager(\n            this.client,\n            this.runtime,\n            this.profileId,\n            cache,\n            this.ipfs\n        );\n\n        this.interactions = new LensInteractionManager(\n            this.client,\n            this.runtime,\n            this.profileId,\n            cache,\n            this.ipfs\n        );\n    }\n\n    async start() {\n        await Promise.all([this.posts.start(), this.interactions.start()]);\n    }\n\n    async stop() {\n        await Promise.all([this.posts.stop(), this.interactions.stop()]);\n    }\n}\n","import { IAgentRuntime, elizaLogger } from \"@ai16z/eliza\";\nimport {\n    AnyPublicationFragment,\n    LensClient as LensClientCore,\n    production,\n    LensTransactionStatusType,\n    LimitType,\n    NotificationType,\n    ProfileFragment,\n    PublicationType,\n    FeedEventItemType,\n} from \"@lens-protocol/client\";\nimport { Profile, BroadcastResult } from \"./types\";\nimport { PrivateKeyAccount } from \"viem\";\nimport { getProfilePictureUri, handleBroadcastResult, omit } from \"./utils\";\n\nexport class LensClient {\n    runtime: IAgentRuntime;\n    account: PrivateKeyAccount;\n    cache: Map<string, any>;\n    lastInteractionTimestamp: Date;\n    profileId: `0x${string}`;\n\n    private authenticated: boolean;\n    private authenticatedProfile: ProfileFragment | null;\n    private core: LensClientCore;\n\n    constructor(opts: {\n        runtime: IAgentRuntime;\n        cache: Map<string, any>;\n        account: PrivateKeyAccount;\n        profileId: `0x${string}`;\n    }) {\n        this.cache = opts.cache;\n        this.runtime = opts.runtime;\n        this.account = opts.account;\n        this.core = new LensClientCore({\n            environment: production,\n        });\n        this.lastInteractionTimestamp = new Date();\n        this.profileId = opts.profileId;\n        this.authenticated = false;\n        this.authenticatedProfile = null;\n    }\n\n    async authenticate(): Promise<void> {\n        try {\n            const { id, text } =\n                await this.core.authentication.generateChallenge({\n                    signedBy: this.account.address,\n                    for: this.profileId,\n                });\n\n            const signature = await this.account.signMessage({\n                message: text,\n            });\n\n            await this.core.authentication.authenticate({ id, signature });\n            this.authenticatedProfile = await this.core.profile.fetch({\n                forProfileId: this.profileId,\n            });\n\n            this.authenticated = true;\n        } catch (error) {\n            elizaLogger.error(\"client-lens::client error: \", error);\n            throw error;\n        }\n    }\n\n    async createPublication(\n        contentURI: string,\n        onchain: boolean = false,\n        commentOn?: string\n    ): Promise<AnyPublicationFragment | null | undefined> {\n        try {\n            if (!this.authenticated) {\n                await this.authenticate();\n                elizaLogger.log(\"done authenticating\");\n            }\n            let broadcastResult;\n\n            if (commentOn) {\n                broadcastResult = onchain\n                    ? await this.createCommentOnchain(contentURI, commentOn)\n                    : await this.createCommentMomoka(contentURI, commentOn);\n            } else {\n                broadcastResult = onchain\n                    ? await this.createPostOnchain(contentURI)\n                    : await this.createPostMomoka(contentURI);\n            }\n\n            elizaLogger.log(\"broadcastResult\", broadcastResult);\n\n            if (broadcastResult.id) {\n                return await this.core.publication.fetch({\n                    forId: broadcastResult.id,\n                });\n            }\n\n            const completion = await this.core.transaction.waitUntilComplete({\n                forTxHash: broadcastResult.txHash,\n            });\n\n            if (completion?.status === LensTransactionStatusType.Complete) {\n                return await this.core.publication.fetch({\n                    forTxHash: completion?.txHash,\n                });\n            }\n        } catch (error) {\n            elizaLogger.error(\"client-lens::client error: \", error);\n            throw error;\n        }\n    }\n\n    async getPublication(\n        pubId: string\n    ): Promise<AnyPublicationFragment | null> {\n        if (this.cache.has(`lens/publication/${pubId}`)) {\n            return this.cache.get(`lens/publication/${pubId}`);\n        }\n\n        const publication = await this.core.publication.fetch({ forId: pubId });\n\n        if (publication)\n            this.cache.set(`lens/publication/${pubId}`, publication);\n\n        return publication;\n    }\n\n    async getPublicationsFor(\n        profileId: string,\n        limit: number = 50\n    ): Promise<AnyPublicationFragment[]> {\n        const timeline: AnyPublicationFragment[] = [];\n        let next: any | undefined = undefined;\n\n        do {\n            const { items, next: newNext } = next\n                ? await next()\n                : await this.core.publication.fetchAll({\n                      limit: LimitType.Fifty,\n                      where: {\n                          from: [profileId],\n                          publicationTypes: [PublicationType.Post],\n                      },\n                  });\n\n            items.forEach((publication) => {\n                this.cache.set(\n                    `lens/publication/${publication.id}`,\n                    publication\n                );\n                timeline.push(publication);\n            });\n\n            next = newNext;\n        } while (next && timeline.length < limit);\n\n        return timeline;\n    }\n\n    async getMentions(): Promise<{\n        mentions: AnyPublicationFragment[];\n        next?: () => {};\n    }> {\n        if (!this.authenticated) {\n            await this.authenticate();\n        }\n        // TODO: we should limit to new ones or at least latest n\n        const result = await this.core.notifications.fetch({\n            where: {\n                highSignalFilter: false, // true,\n                notificationTypes: [\n                    NotificationType.Mentioned,\n                    NotificationType.Commented,\n                ],\n            },\n        });\n        const mentions: AnyPublicationFragment[] = [];\n\n        const { items, next } = result.unwrap();\n\n        items.map((notification) => {\n            // @ts-ignore NotificationFragment\n            const item = notification.publication || notification.comment;\n            if (!item.isEncrypted) {\n                mentions.push(item);\n                this.cache.set(`lens/publication/${item.id}`, item);\n            }\n        });\n\n        return { mentions, next };\n    }\n\n    async getProfile(profileId: string): Promise<Profile> {\n        if (this.cache.has(`lens/profile/${profileId}`)) {\n            return this.cache.get(`lens/profile/${profileId}`) as Profile;\n        }\n\n        const result = await this.core.profile.fetch({\n            forProfileId: profileId,\n        });\n        if (!result?.id) {\n            elizaLogger.error(\"Error fetching user by profileId\");\n\n            throw \"getProfile ERROR\";\n        }\n\n        const profile: Profile = {\n            id: \"\",\n            profileId,\n            name: \"\",\n            handle: \"\",\n        };\n\n        profile.id = result.id;\n        profile.name = result.metadata?.displayName;\n        profile.handle = result.handle?.localName;\n        profile.bio = result.metadata?.bio;\n        profile.pfp = getProfilePictureUri(result.metadata?.picture);\n\n        this.cache.set(`lens/profile/${profileId}`, profile);\n\n        return profile;\n    }\n\n    async getTimeline(\n        profileId: string,\n        limit: number = 10\n    ): Promise<AnyPublicationFragment[]> {\n        try {\n            if (!this.authenticated) {\n                await this.authenticate();\n            }\n            const timeline: AnyPublicationFragment[] = [];\n            let next: any | undefined = undefined;\n\n            do {\n                const result = next\n                    ? await next()\n                    : await this.core.feed.fetch({\n                          where: {\n                              for: profileId,\n                              feedEventItemTypes: [FeedEventItemType.Post],\n                          },\n                      });\n\n                const data = result.unwrap();\n\n                data.items.forEach((item) => {\n                    // private posts in orb clubs are encrypted\n                    if (timeline.length < limit && !item.root.isEncrypted) {\n                        this.cache.set(\n                            `lens/publication/${item.id}`,\n                            item.root\n                        );\n                        timeline.push(item.root as AnyPublicationFragment);\n                    }\n                });\n\n                next = data.pageInfo.next;\n            } while (next && timeline.length < limit);\n\n            return timeline;\n        } catch (error) {\n            console.log(error);\n            throw new Error(\"client-lens:: getTimeline\");\n        }\n    }\n\n    private async createPostOnchain(\n        contentURI: string\n    ): Promise<BroadcastResult | undefined> {\n        // gasless + signless if they enabled the lens profile manager\n        if (this.authenticatedProfile?.signless) {\n            const broadcastResult = await this.core.publication.postOnchain({\n                contentURI,\n                openActionModules: [], // TODO: if collectable\n            });\n            return handleBroadcastResult(broadcastResult);\n        }\n\n        // gasless with signed type data\n        const typedDataResult =\n            await this.core.publication.createOnchainPostTypedData({\n                contentURI,\n                openActionModules: [], // TODO: if collectable\n            });\n        const { id, typedData } = typedDataResult.unwrap();\n\n        const signedTypedData = await this.account.signTypedData({\n            domain: omit(typedData.domain as any, \"__typename\"),\n            types: omit(typedData.types, \"__typename\"),\n            primaryType: \"Post\",\n            message: omit(typedData.value, \"__typename\"),\n        });\n\n        const broadcastResult = await this.core.transaction.broadcastOnchain({\n            id,\n            signature: signedTypedData,\n        });\n        return handleBroadcastResult(broadcastResult);\n    }\n\n    private async createPostMomoka(\n        contentURI: string\n    ): Promise<BroadcastResult | undefined> {\n        console.log(\"createPostMomoka\");\n        // gasless + signless if they enabled the lens profile manager\n        if (this.authenticatedProfile?.signless) {\n            const broadcastResult = await this.core.publication.postOnMomoka({\n                contentURI,\n            });\n            return handleBroadcastResult(broadcastResult);\n        }\n\n        // gasless with signed type data\n        const typedDataResult =\n            await this.core.publication.createMomokaPostTypedData({\n                contentURI,\n            });\n        console.log(\"typedDataResult\", typedDataResult);\n        const { id, typedData } = typedDataResult.unwrap();\n\n        const signedTypedData = await this.account.signTypedData({\n            domain: omit(typedData.domain as any, \"__typename\"),\n            types: omit(typedData.types, \"__typename\"),\n            primaryType: \"Post\",\n            message: omit(typedData.value, \"__typename\"),\n        });\n\n        const broadcastResult = await this.core.transaction.broadcastOnMomoka({\n            id,\n            signature: signedTypedData,\n        });\n        return handleBroadcastResult(broadcastResult);\n    }\n\n    private async createCommentOnchain(\n        contentURI: string,\n        commentOn: string\n    ): Promise<BroadcastResult | undefined> {\n        // gasless + signless if they enabled the lens profile manager\n        if (this.authenticatedProfile?.signless) {\n            const broadcastResult = await this.core.publication.commentOnchain({\n                commentOn,\n                contentURI,\n            });\n            return handleBroadcastResult(broadcastResult);\n        }\n\n        // gasless with signed type data\n        const typedDataResult =\n            await this.core.publication.createOnchainCommentTypedData({\n                commentOn,\n                contentURI,\n            });\n\n        const { id, typedData } = typedDataResult.unwrap();\n\n        const signedTypedData = await this.account.signTypedData({\n            domain: omit(typedData.domain as any, \"__typename\"),\n            types: omit(typedData.types, \"__typename\"),\n            primaryType: \"Comment\",\n            message: omit(typedData.value, \"__typename\"),\n        });\n\n        const broadcastResult = await this.core.transaction.broadcastOnchain({\n            id,\n            signature: signedTypedData,\n        });\n        return handleBroadcastResult(broadcastResult);\n    }\n\n    private async createCommentMomoka(\n        contentURI: string,\n        commentOn: string\n    ): Promise<BroadcastResult | undefined> {\n        // gasless + signless if they enabled the lens profile manager\n        if (this.authenticatedProfile?.signless) {\n            const broadcastResult = await this.core.publication.commentOnMomoka(\n                {\n                    commentOn,\n                    contentURI,\n                }\n            );\n            return handleBroadcastResult(broadcastResult);\n        }\n\n        // gasless with signed type data\n        const typedDataResult =\n            await this.core.publication.createMomokaCommentTypedData({\n                commentOn,\n                contentURI,\n            });\n\n        const { id, typedData } = typedDataResult.unwrap();\n\n        const signedTypedData = await this.account.signTypedData({\n            domain: omit(typedData.domain as any, \"__typename\"),\n            types: omit(typedData.types, \"__typename\"),\n            primaryType: \"Comment\",\n            message: omit(typedData.value, \"__typename\"),\n        });\n\n        const broadcastResult = await this.core.transaction.broadcastOnMomoka({\n            id,\n            signature: signedTypedData,\n        });\n        return handleBroadcastResult(broadcastResult);\n    }\n}\n","import { stringToUuid } from \"@ai16z/eliza\";\nimport { BroadcastResult } from \"./types\";\n\nexport function publicationId({\n    pubId,\n    agentId,\n}: {\n    pubId: string;\n    agentId: string;\n}) {\n    return `${pubId}-${agentId}`;\n}\n\nexport function publicationUuid(props: { pubId: string; agentId: string }) {\n    return stringToUuid(publicationId(props));\n}\n\nexport function populateMentions(\n    text: string,\n    userIds: number[],\n    positions: number[],\n    userMap: Record<number, string>\n) {\n    // Validate input arrays have same length\n    if (userIds.length !== positions.length) {\n        throw new Error(\n            \"User IDs and positions arrays must have the same length\"\n        );\n    }\n\n    // Create array of mention objects with position and user info\n    const mentions = userIds\n        .map((userId, index) => ({\n            position: positions[index],\n            userId,\n            displayName: userMap[userId]!,\n        }))\n        .sort((a, b) => b.position - a.position); // Sort in reverse order to prevent position shifting\n\n    // Create the resulting string by inserting mentions\n    let result = text;\n    mentions.forEach((mention) => {\n        const mentionText = `@${mention.displayName}`;\n        result =\n            result.slice(0, mention.position) +\n            mentionText +\n            result.slice(mention.position);\n    });\n\n    return result;\n}\n\nexport const handleBroadcastResult = (\n    broadcastResult: any\n): BroadcastResult | undefined => {\n    const broadcastValue = broadcastResult.unwrap();\n\n    if (\"id\" in broadcastValue || \"txId\" in broadcastValue) {\n        return broadcastValue;\n    } else {\n        throw new Error();\n    }\n};\n\nexport const getProfilePictureUri = (picture: any): string | undefined => {\n    if (\"optimized\" in picture) {\n        return picture.optimized?.uri || picture.raw?.uri || picture.uri;\n    } else {\n        return picture.uri;\n    }\n};\n\nexport function omit<T extends object, K extends string>(\n    obj: T,\n    key: K\n): Omit<T, K> {\n    const result: any = {};\n    Object.keys(obj).forEach((currentKey) => {\n        if (currentKey !== key) {\n            result[currentKey] = obj[currentKey];\n        }\n    });\n    return result;\n}\n","import {\n    composeContext,\n    generateText,\n    IAgentRuntime,\n    ModelClass,\n    stringToUuid,\n    elizaLogger,\n} from \"@ai16z/eliza\";\nimport { LensClient } from \"./client\";\nimport { formatTimeline, postTemplate } from \"./prompts\";\nimport { publicationUuid } from \"./utils\";\nimport { createPublicationMemory } from \"./memory\";\nimport { sendPublication } from \"./actions\";\nimport StorjProvider from \"./providers/StorjProvider\";\n\nexport class LensPostManager {\n    private timeout: NodeJS.Timeout | undefined;\n\n    constructor(\n        public client: LensClient,\n        public runtime: IAgentRuntime,\n        private profileId: string,\n        public cache: Map<string, any>,\n        private ipfs: StorjProvider\n    ) {}\n\n    public async start() {\n        const generateNewPubLoop = async () => {\n            try {\n                await this.generateNewPublication();\n            } catch (error) {\n                elizaLogger.error(error);\n                return;\n            }\n\n            this.timeout = setTimeout(\n                generateNewPubLoop,\n                (Math.floor(Math.random() * (4 - 1 + 1)) + 1) * 60 * 60 * 1000\n            ); // Random interval between 1 and 4 hours\n        };\n\n        generateNewPubLoop();\n    }\n\n    public async stop() {\n        if (this.timeout) clearTimeout(this.timeout);\n    }\n\n    private async generateNewPublication() {\n        elizaLogger.info(\"Generating new publication\");\n        try {\n            const profile = await this.client.getProfile(this.profileId);\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                profile.handle!,\n                this.runtime.character.name,\n                \"lens\"\n            );\n\n            const timeline = await this.client.getTimeline(this.profileId);\n\n            // this.cache.set(\"lens/timeline\", timeline);\n\n            const formattedHomeTimeline = formatTimeline(\n                this.runtime.character,\n                timeline\n            );\n\n            const generateRoomId = stringToUuid(\"lens_generate_room\");\n\n            const state = await this.runtime.composeState(\n                {\n                    roomId: generateRoomId,\n                    userId: this.runtime.agentId,\n                    agentId: this.runtime.agentId,\n                    content: { text: \"\", action: \"\" },\n                },\n                {\n                    lensHandle: profile.handle,\n                    timeline: formattedHomeTimeline,\n                }\n            );\n\n            const context = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.lensPostTemplate ||\n                    postTemplate,\n            });\n\n            const content = await generateText({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            if (this.runtime.getSetting(\"LENS_DRY_RUN\") === \"true\") {\n                elizaLogger.info(`Dry run: would have posted: ${content}`);\n                return;\n            }\n\n            try {\n                const { publication } = await sendPublication({\n                    client: this.client,\n                    runtime: this.runtime,\n                    roomId: generateRoomId,\n                    content: { text: content },\n                    ipfs: this.ipfs,\n                });\n\n                if (!publication) throw new Error(\"failed to send publication\");\n\n                const roomId = publicationUuid({\n                    agentId: this.runtime.agentId,\n                    pubId: publication.id,\n                });\n\n                await this.runtime.ensureRoomExists(roomId);\n\n                await this.runtime.ensureParticipantInRoom(\n                    this.runtime.agentId,\n                    roomId\n                );\n\n                elizaLogger.info(`[Lens Client] Published ${publication.id}`);\n\n                await this.runtime.messageManager.createMemory(\n                    createPublicationMemory({\n                        roomId,\n                        runtime: this.runtime,\n                        publication,\n                    })\n                );\n            } catch (error) {\n                elizaLogger.error(\"Error sending publication:\", error);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error generating new publication:\", error);\n        }\n    }\n}\n","import {\n    Character,\n    messageCompletionFooter,\n    shouldRespondFooter,\n} from \"@ai16z/eliza\";\nimport { AnyPublicationFragment } from \"@lens-protocol/client\";\n\nexport const formatPublication = (publication: AnyPublicationFragment) => {\n    return `ID: ${publication.id}\n    From: ${publication.by.metadata?.displayName} (@${publication.by.handle?.localName})${publication.by.handle?.localName})${publication.commentOn ? `\\nIn reply to: @${publication.commentOn.by.handle?.localName}` : \"\"}\nText: ${publication.metadata.content}`;\n};\n\nexport const formatTimeline = (\n    character: Character,\n    timeline: AnyPublicationFragment[]\n) => `# ${character.name}'s Home Timeline\n${timeline.map(formatPublication).join(\"\\n\")}\n`;\n\nexport const headerTemplate = `\n{{timeline}}\n\n# Knowledge\n{{knowledge}}\n\nAbout {{agentName}} (@{{lensHandle}}):\n{{bio}}\n{{lore}}\n{{postDirections}}\n\n{{providers}}\n\n{{recentPosts}}\n\n{{characterPostExamples}}`;\n\nexport const postTemplate =\n    headerTemplate +\n    `\n# Task: Generate a post in the voice and style of {{agentName}}, aka @{{lensHandle}}\nWrite a single sentence post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}.\nTry to write something totally different than previous posts. Do not add commentary or ackwowledge this request, just write the post.\n\nYour response should not contain any questions. Brief, concise statements only. No emojis. Use \\\\n\\\\n (double spaces) between statements.`;\n\nexport const messageHandlerTemplate =\n    headerTemplate +\n    `\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\nThread of publications You Are Replying To:\n{{formattedConversation}}\n\n# Task: Generate a post in the voice, style and perspective of {{agentName}} (@{{lensHandle}}):\n{{currentPost}}` +\n    messageCompletionFooter;\n\nexport const shouldRespondTemplate =\n    //\n    `# Task: Decide if {{agentName}} should respond.\n    About {{agentName}}:\n    {{bio}}\n\n    # INSTRUCTIONS: Determine if {{agentName}} (@{{lensHandle}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"RESPOND\" or \"IGNORE\" or \"STOP\".\n\nResponse options are RESPOND, IGNORE and STOP.\n\n{{agentName}} should respond to messages that are directed at them, or participate in conversations that are interesting or relevant to their background, IGNORE messages that are irrelevant to them, and should STOP if the conversation is concluded.\n\n{{agentName}} is in a room with other users and wants to be conversational, but not annoying.\n{{agentName}} should RESPOND to messages that are directed at them, or participate in conversations that are interesting or relevant to their background.\nIf a message is not interesting or relevant, {{agentName}} should IGNORE.\nIf a message thread has become repetitive, {{agentName}} should IGNORE.\nUnless directly RESPONDing to a user, {{agentName}} should IGNORE messages that are very short or do not contain much information.\nIf a user asks {{agentName}} to stop talking, {{agentName}} should STOP.\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, {{agentName}} should STOP.\n\nIMPORTANT: {{agentName}} (aka @{{lensHandle}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\n\nThread of messages You Are Replying To:\n{{formattedConversation}}\n\nCurrent message:\n{{currentPost}}\n\n` + shouldRespondFooter;\n","import {\n    elizaLogger,\n    getEmbeddingZeroVector,\n    IAgentRuntime,\n    stringToUuid,\n    type Memory,\n    type UUID,\n} from \"@ai16z/eliza\";\nimport { publicationUuid } from \"./utils\";\nimport { LensClient } from \"./client\";\nimport { AnyPublicationFragment } from \"@lens-protocol/client\";\n\nexport function createPublicationMemory({\n    roomId,\n    runtime,\n    publication,\n}: {\n    roomId: UUID;\n    runtime: IAgentRuntime;\n    publication: AnyPublicationFragment;\n}): Memory {\n    const commentOn = publication.commentOn\n        ? publicationUuid({\n              pubId: publication.commentOn.id,\n              agentId: runtime.agentId,\n          })\n        : undefined;\n\n    return {\n        id: publicationUuid({\n            pubId: publication.id,\n            agentId: runtime.agentId,\n        }),\n        agentId: runtime.agentId,\n        userId: runtime.agentId,\n        content: {\n            text: publication.metadata.content,\n            source: \"lens\",\n            url: \"\",\n            commentOn,\n            id: publication.id,\n        },\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n    };\n}\n\nexport async function buildConversationThread({\n    publication,\n    runtime,\n    client,\n}: {\n    publication: AnyPublicationFragment;\n    runtime: IAgentRuntime;\n    client: LensClient;\n}): Promise<AnyPublicationFragment[]> {\n    const thread: AnyPublicationFragment[] = [];\n    const visited: Set<string> = new Set();\n    async function processThread(currentPublication: AnyPublicationFragment) {\n        if (visited.has(currentPublication.id)) {\n            return;\n        }\n\n        visited.add(currentPublication.id);\n\n        const roomId = publicationUuid({\n            pubId: currentPublication.id,\n            agentId: runtime.agentId,\n        });\n\n        // Check if the current cast has already been saved\n        const memory = await runtime.messageManager.getMemoryById(roomId);\n\n        if (!memory) {\n            elizaLogger.log(\n                \"Creating memory for publication\",\n                currentPublication.id\n            );\n\n            const userId = stringToUuid(currentPublication.by.id);\n\n            await runtime.ensureConnection(\n                userId,\n                roomId,\n                currentPublication.by.id,\n                currentPublication.by.metadata?.displayName ||\n                    currentPublication.by.handle?.localName,\n                \"lens\"\n            );\n\n            await runtime.messageManager.createMemory(\n                createPublicationMemory({\n                    roomId,\n                    runtime,\n                    publication: currentPublication,\n                })\n            );\n        }\n\n        thread.unshift(currentPublication);\n\n        if (currentPublication.commentOn) {\n            const parentPublication = await client.getPublication(\n                currentPublication.commentOn.id\n            );\n            if (parentPublication) await processThread(parentPublication);\n        }\n    }\n\n    await processThread(publication);\n    return thread;\n}\n","import type { LensClient } from \"./client\";\nimport {\n    elizaLogger,\n    type Content,\n    type IAgentRuntime,\n    type Memory,\n    type UUID,\n} from \"@ai16z/eliza\";\nimport { textOnly } from \"@lens-protocol/metadata\";\nimport { createPublicationMemory } from \"./memory\";\nimport { AnyPublicationFragment } from \"@lens-protocol/client\";\nimport StorjProvider from \"./providers/StorjProvider\";\n\nexport async function sendPublication({\n    client,\n    runtime,\n    content,\n    roomId,\n    commentOn,\n    ipfs,\n}: {\n    client: LensClient;\n    runtime: IAgentRuntime;\n    content: Content;\n    roomId: UUID;\n    commentOn?: string;\n    ipfs: StorjProvider;\n}): Promise<{ memory?: Memory; publication?: AnyPublicationFragment }> {\n    // TODO: arweave provider for content hosting\n    const metadata = textOnly({ content: content.text });\n    const contentURI = await ipfs.pinJson(metadata);\n\n    const publication = await client.createPublication(\n        contentURI,\n        false, // TODO: support collectable settings\n        commentOn\n    );\n\n    if (publication) {\n        return {\n            publication,\n            memory: createPublicationMemory({\n                roomId,\n                runtime,\n                publication: publication as AnyPublicationFragment,\n            }),\n        };\n    }\n\n    return {};\n}\n","import {\n    composeContext,\n    generateMessageResponse,\n    generateShouldRespond,\n    Memory,\n    ModelClass,\n    stringToUuid,\n    elizaLogger,\n    HandlerCallback,\n    Content,\n    type IAgentRuntime,\n} from \"@ai16z/eliza\";\nimport type { LensClient } from \"./client\";\nimport { toHex } from \"viem\";\nimport { buildConversationThread, createPublicationMemory } from \"./memory\";\nimport {\n    formatPublication,\n    formatTimeline,\n    messageHandlerTemplate,\n    shouldRespondTemplate,\n} from \"./prompts\";\nimport { publicationUuid } from \"./utils\";\nimport { sendPublication } from \"./actions\";\nimport { AnyPublicationFragment } from \"@lens-protocol/client\";\nimport { Profile } from \"./types\";\nimport StorjProvider from \"./providers/StorjProvider\";\n\nexport class LensInteractionManager {\n    private timeout: NodeJS.Timeout | undefined;\n    constructor(\n        public client: LensClient,\n        public runtime: IAgentRuntime,\n        private profileId: string,\n        public cache: Map<string, any>,\n        private ipfs: StorjProvider\n    ) {}\n\n    public async start() {\n        const handleInteractionsLoop = async () => {\n            try {\n                await this.handleInteractions();\n            } catch (error) {\n                elizaLogger.error(error);\n                return;\n            }\n\n            this.timeout = setTimeout(\n                handleInteractionsLoop,\n                Number(this.runtime.getSetting(\"LENS_POLL_INTERVAL\") || 120) *\n                    1000 // Default to 2 minutes\n            );\n        };\n\n        handleInteractionsLoop();\n    }\n\n    public async stop() {\n        if (this.timeout) clearTimeout(this.timeout);\n    }\n\n    private async handleInteractions() {\n        elizaLogger.info(\"Handle Lens interactions\");\n        // TODO: handle next() for pagination\n        const { mentions } = await this.client.getMentions();\n\n        const agent = await this.client.getProfile(this.profileId);\n        for (const mention of mentions) {\n            const messageHash = toHex(mention.id);\n            const conversationId = `${messageHash}-${this.runtime.agentId}`;\n            const roomId = stringToUuid(conversationId);\n            const userId = stringToUuid(mention.by.id);\n\n            const pastMemoryId = publicationUuid({\n                agentId: this.runtime.agentId,\n                pubId: mention.id,\n            });\n\n            const pastMemory =\n                await this.runtime.messageManager.getMemoryById(pastMemoryId);\n\n            if (pastMemory) {\n                continue;\n            }\n\n            await this.runtime.ensureConnection(\n                userId,\n                roomId,\n                mention.by.id,\n                mention.by.metadata?.displayName ||\n                    mention.by.handle?.localName,\n                \"lens\"\n            );\n\n            const thread = await buildConversationThread({\n                client: this.client,\n                runtime: this.runtime,\n                publication: mention,\n            });\n\n            const memory: Memory = {\n                // @ts-ignore Metadata\n                content: { text: mention.metadata.content, hash: mention.id },\n                agentId: this.runtime.agentId,\n                userId,\n                roomId,\n            };\n\n            await this.handlePublication({\n                agent,\n                publication: mention,\n                memory,\n                thread,\n            });\n        }\n\n        this.client.lastInteractionTimestamp = new Date();\n    }\n\n    private async handlePublication({\n        agent,\n        publication,\n        memory,\n        thread,\n    }: {\n        agent: Profile;\n        publication: AnyPublicationFragment;\n        memory: Memory;\n        thread: AnyPublicationFragment[];\n    }) {\n        if (publication.by.id === agent.id) {\n            elizaLogger.info(\"skipping cast from bot itself\", publication.id);\n            return;\n        }\n\n        if (!memory.content.text) {\n            elizaLogger.info(\"skipping cast with no text\", publication.id);\n            return { text: \"\", action: \"IGNORE\" };\n        }\n\n        const currentPost = formatPublication(publication);\n\n        const timeline = await this.client.getTimeline(this.profileId);\n\n        const formattedTimeline = formatTimeline(\n            this.runtime.character,\n            timeline\n        );\n\n        const formattedConversation = thread\n            .map((pub) => {\n                // @ts-ignore Metadata\n                const content = pub.metadata.content;\n                return `@${pub.by.handle?.localName} (${new Date(\n                    pub.createdAt\n                ).toLocaleString(\"en-US\", {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                    month: \"short\",\n                    day: \"numeric\",\n                })}):\n                ${content}`;\n            })\n            .join(\"\\n\\n\");\n\n        const state = await this.runtime.composeState(memory, {\n            lensHandle: agent.handle,\n            timeline: formattedTimeline,\n            currentPost,\n            formattedConversation,\n        });\n\n        const shouldRespondContext = composeContext({\n            state,\n            template:\n                this.runtime.character.templates?.lensShouldRespondTemplate ||\n                this.runtime.character?.templates?.shouldRespondTemplate ||\n                shouldRespondTemplate,\n        });\n\n        const memoryId = publicationUuid({\n            agentId: this.runtime.agentId,\n            pubId: publication.id,\n        });\n\n        const castMemory =\n            await this.runtime.messageManager.getMemoryById(memoryId);\n\n        if (!castMemory) {\n            await this.runtime.messageManager.createMemory(\n                createPublicationMemory({\n                    roomId: memory.roomId,\n                    runtime: this.runtime,\n                    publication,\n                })\n            );\n        }\n\n        const shouldRespondResponse = await generateShouldRespond({\n            runtime: this.runtime,\n            context: shouldRespondContext,\n            modelClass: ModelClass.SMALL,\n        });\n\n        if (\n            shouldRespondResponse === \"IGNORE\" ||\n            shouldRespondResponse === \"STOP\"\n        ) {\n            elizaLogger.info(\n                `Not responding to publication because generated ShouldRespond was ${shouldRespondResponse}`\n            );\n            return;\n        }\n\n        const context = composeContext({\n            state,\n            template:\n                this.runtime.character.templates?.lensMessageHandlerTemplate ??\n                this.runtime.character?.templates?.messageHandlerTemplate ??\n                messageHandlerTemplate,\n        });\n\n        const responseContent = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.LARGE,\n        });\n\n        responseContent.inReplyTo = memoryId;\n\n        if (!responseContent.text) return;\n\n        if (this.runtime.getSetting(\"LENS_DRY_RUN\") === \"true\") {\n            elizaLogger.info(\n                `Dry run: would have responded to publication ${publication.id} with ${responseContent.text}`\n            );\n            return;\n        }\n\n        const callback: HandlerCallback = async (\n            content: Content,\n            files: any[]\n        ) => {\n            try {\n                if (memoryId && !content.inReplyTo) {\n                    content.inReplyTo = memoryId;\n                }\n                const result = await sendPublication({\n                    runtime: this.runtime,\n                    client: this.client,\n                    content: content,\n                    roomId: memory.roomId,\n                    commentOn: publication.id,\n                    ipfs: this.ipfs,\n                });\n                if (!result.publication?.id)\n                    throw new Error(\"publication not sent\");\n\n                // sendPublication lost response action, so we need to add it back here?\n                result.memory!.content.action = content.action;\n\n                await this.runtime.messageManager.createMemory(result.memory!);\n                return [result.memory!];\n            } catch (error) {\n                console.error(\"Error sending response cast:\", error);\n                return [];\n            }\n        };\n\n        const responseMessages = await callback(responseContent);\n\n        const newState = await this.runtime.updateRecentMessageState(state);\n\n        await this.runtime.processActions(\n            memory,\n            responseMessages,\n            newState,\n            callback\n        );\n    }\n}\n","import axios, { AxiosInstance } from \"axios\";\nimport FormData from \"form-data\";\nimport type { IAgentRuntime } from \"@ai16z/eliza\";\n\n// ipfs pinning service: https://storj.dev/dcs/api/storj-ipfs-pinning\nclass StorjProvider {\n    private STORJ_API_URL: string = \"https://www.storj-ipfs.com\";\n    private STORJ_API_USERNAME: string;\n    private STORJ_API_PASSWORD: string;\n    private baseURL: string;\n    private client: AxiosInstance;\n\n    constructor(runtime: IAgentRuntime) {\n        this.STORJ_API_USERNAME = runtime.getSetting(\"STORJ_API_USERNAME\")!;\n        this.STORJ_API_PASSWORD = runtime.getSetting(\"STORJ_API_PASSWORD\")!;\n        this.baseURL = `${this.STORJ_API_URL}/api/v0`;\n        this.client = this.createClient();\n    }\n\n    private createClient(): AxiosInstance {\n        return axios.create({\n            baseURL: this.baseURL,\n            auth: {\n                username: this.STORJ_API_USERNAME,\n                password: this.STORJ_API_PASSWORD,\n            },\n        });\n    }\n\n    private hash(uriOrHash: string): string {\n        return typeof uriOrHash === \"string\" && uriOrHash.startsWith(\"ipfs://\")\n            ? uriOrHash.split(\"ipfs://\")[1]\n            : uriOrHash;\n    }\n\n    public gatewayURL(uriOrHash: string): string {\n        return `${this.STORJ_API_URL}/ipfs/${this.hash(uriOrHash)}`;\n    }\n\n    public async pinJson(json: any): Promise<string> {\n        if (typeof json !== \"string\") {\n            json = JSON.stringify(json);\n        }\n        const formData = new FormData();\n        formData.append(\"path\", Buffer.from(json, \"utf-8\").toString());\n\n        const headers = {\n            \"Content-Type\": \"multipart/form-data\",\n            ...formData.getHeaders(),\n        };\n\n        const { data } = await this.client.post(\n            \"add?cid-version=1\",\n            formData.getBuffer(),\n            { headers }\n        );\n\n        return this.gatewayURL(data.Hash);\n    }\n\n    public async pinFile(file: {\n        buffer: Buffer;\n        originalname: string;\n        mimetype: string;\n    }): Promise<string> {\n        const formData = new FormData();\n        formData.append(\"file\", file.buffer, {\n            filename: file.originalname,\n            contentType: file.mimetype,\n        });\n\n        const response = await this.client.post(\"add?cid-version=1\", formData, {\n            headers: {\n                \"Content-Type\": `multipart/form-data; boundary=${formData.getBoundary()}`,\n            },\n            maxContentLength: Infinity,\n            maxBodyLength: Infinity,\n        });\n\n        return this.gatewayURL(response.data.Hash);\n    }\n}\n\nexport default StorjProvider;\n"],"mappings":"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","names":["elizaLogger","broadcastResult","stringToUuid","elizaLogger","elizaLogger","stringToUuid","elizaLogger","stringToUuid","elizaLogger","stringToUuid","composeContext","ModelClass","stringToUuid","elizaLogger","elizaLogger","stringToUuid","composeContext","ModelClass","elizaLogger"]}