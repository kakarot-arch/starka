{"version":3,"sources":["../src/index.ts","../src/telegramClient.ts","../src/messageManager.ts","../src/utils.ts","../src/constants.ts","../src/getOrCreateRecommenderInBe.ts","../src/environment.ts"],"sourcesContent":["import { elizaLogger } from \"@ai16z/eliza\";\nimport { Client, IAgentRuntime } from \"@ai16z/eliza\";\nimport { TelegramClient } from \"./telegramClient.ts\";\nimport { validateTelegramConfig } from \"./environment.ts\";\n\nexport const TelegramClientInterface: Client = {\n    start: async (runtime: IAgentRuntime) => {\n        await validateTelegramConfig(runtime);\n\n        const tg = new TelegramClient(\n            runtime,\n            runtime.getSetting(\"TELEGRAM_BOT_TOKEN\")\n        );\n\n        await tg.start();\n\n        elizaLogger.success(\n            `‚úÖ Telegram client successfully started for character ${runtime.character.name}`\n        );\n        return tg;\n    },\n    stop: async (_runtime: IAgentRuntime) => {\n        elizaLogger.warn(\"Telegram client does not support stopping yet\");\n    },\n};\n\nexport default TelegramClientInterface;\n","import { Context, Telegraf } from \"telegraf\";\nimport { message } from 'telegraf/filters';\nimport { IAgentRuntime, elizaLogger } from \"@ai16z/eliza\";\nimport { MessageManager } from \"./messageManager.ts\";\nimport { getOrCreateRecommenderInBe } from \"./getOrCreateRecommenderInBe.ts\";\n\nexport class TelegramClient {\n    private bot: Telegraf<Context>;\n    private runtime: IAgentRuntime;\n    private messageManager: MessageManager;\n    private backend;\n    private backendToken;\n    private tgTrader;\n\n    constructor(runtime: IAgentRuntime, botToken: string) {\n        elizaLogger.log(\"üì± Constructing new TelegramClient...\");\n        this.runtime = runtime;\n        this.bot = new Telegraf(botToken);\n        this.messageManager = new MessageManager(this.bot, this.runtime);\n        this.backend = runtime.getSetting(\"BACKEND_URL\");\n        this.backendToken = runtime.getSetting(\"BACKEND_TOKEN\");\n        this.tgTrader = runtime.getSetting(\"TG_TRADER\"); // boolean To Be added to the settings\n        elizaLogger.log(\"‚úÖ TelegramClient constructor completed\");\n    }\n\n    public async start(): Promise<void> {\n        elizaLogger.log(\"üöÄ Starting Telegram bot...\");\n        try {\n            await this.initializeBot();\n            this.setupMessageHandlers();\n            this.setupShutdownHandlers();\n        } catch (error) {\n            elizaLogger.error(\"‚ùå Failed to launch Telegram bot:\", error);\n            throw error;\n        }\n    }\n\n    private async initializeBot(): Promise<void> {\n        this.bot.launch({ dropPendingUpdates: true });\n        elizaLogger.log(\n            \"‚ú® Telegram bot successfully launched and is running!\"\n        );\n\n        const botInfo = await this.bot.telegram.getMe();\n        this.bot.botInfo = botInfo;\n        elizaLogger.success(`Bot username: @${botInfo.username}`);\n\n        this.messageManager.bot = this.bot;\n    }\n\n    private async isGroupAuthorized(ctx: Context): Promise<boolean> {\n        const config = this.runtime.character.clientConfig?.telegram;\n        if (ctx.from?.id === ctx.botInfo?.id) {\n            return false;\n        }\n\n        if (!config?.shouldOnlyJoinInAllowedGroups) {\n            return true;\n        }\n\n        const allowedGroups = config.allowedGroupIds || [];\n        const currentGroupId = ctx.chat.id.toString();\n\n        if (!allowedGroups.includes(currentGroupId)) {\n            elizaLogger.info(`Unauthorized group detected: ${currentGroupId}`);\n            try {\n                await ctx.reply(\"Not authorized. Leaving.\");\n                await ctx.leaveChat();\n            } catch (error) {\n                elizaLogger.error(`Error leaving unauthorized group ${currentGroupId}:`, error);\n            }\n            return false;\n        }\n\n        return true;\n    }\n\n    private setupMessageHandlers(): void {\n        elizaLogger.log(\"Setting up message handler...\");\n\n        this.bot.on(message('new_chat_members'), async (ctx) => {\n            try {\n                const newMembers = ctx.message.new_chat_members;\n                const isBotAdded = newMembers.some(member => member.id === ctx.botInfo.id);\n\n                if (isBotAdded && !(await this.isGroupAuthorized(ctx))) {\n                    return;\n                }\n            } catch (error) {\n                elizaLogger.error(\"Error handling new chat members:\", error);\n            }\n        });\n\n        this.bot.on(\"message\", async (ctx) => {\n            try {\n                // Check group authorization first\n                if (!(await this.isGroupAuthorized(ctx))) {\n                    return;\n                }\n\n                if (this.tgTrader) {\n                    const userId = ctx.from?.id.toString();\n                    const username =\n                        ctx.from?.username || ctx.from?.first_name || \"Unknown\";\n                    if (!userId) {\n                        elizaLogger.warn(\n                            \"Received message from a user without an ID.\"\n                        );\n                        return;\n                    }\n                    try {\n                        await getOrCreateRecommenderInBe(\n                            userId,\n                            username,\n                            this.backendToken,\n                            this.backend\n                        );\n                    } catch (error) {\n                        elizaLogger.error(\n                            \"Error getting or creating recommender in backend\",\n                            error\n                        );\n                    }\n                }\n\n                await this.messageManager.handleMessage(ctx);\n            } catch (error) {\n                elizaLogger.error(\"‚ùå Error handling message:\", error);\n                // Don't try to reply if we've left the group or been kicked\n                if (error?.response?.error_code !== 403) {\n                    try {\n                        await ctx.reply(\"An error occurred while processing your message.\");\n                    } catch (replyError) {\n                        elizaLogger.error(\"Failed to send error message:\", replyError);\n                    }\n                }\n            }\n        });\n\n        this.bot.on(\"photo\", (ctx) => {\n            elizaLogger.log(\n                \"üì∏ Received photo message with caption:\",\n                ctx.message.caption\n            );\n        });\n\n        this.bot.on(\"document\", (ctx) => {\n            elizaLogger.log(\n                \"üìé Received document message:\",\n                ctx.message.document.file_name\n            );\n        });\n\n        this.bot.catch((err, ctx) => {\n            elizaLogger.error(`‚ùå Telegram Error for ${ctx.updateType}:`, err);\n            ctx.reply(\"An unexpected error occurred. Please try again later.\");\n        });\n    }\n\n    private setupShutdownHandlers(): void {\n        const shutdownHandler = async (signal: string) => {\n            elizaLogger.log(\n                `‚ö†Ô∏è Received ${signal}. Shutting down Telegram bot gracefully...`\n            );\n            try {\n                await this.stop();\n                elizaLogger.log(\"üõë Telegram bot stopped gracefully\");\n            } catch (error) {\n                elizaLogger.error(\n                    \"‚ùå Error during Telegram bot shutdown:\",\n                    error\n                );\n                throw error;\n            }\n        };\n\n        process.once(\"SIGINT\", () => shutdownHandler(\"SIGINT\"));\n        process.once(\"SIGTERM\", () => shutdownHandler(\"SIGTERM\"));\n        process.once(\"SIGHUP\", () => shutdownHandler(\"SIGHUP\"));\n    }\n\n    public async stop(): Promise<void> {\n        elizaLogger.log(\"Stopping Telegram bot...\");\n        await this.bot.stop();\n        elizaLogger.log(\"Telegram bot stopped\");\n    }\n}\n","import { Message } from \"@telegraf/types\";\nimport { Context, Telegraf } from \"telegraf\";\n\nimport { composeContext, elizaLogger, ServiceType } from \"@ai16z/eliza\";\nimport { getEmbeddingZeroVector } from \"@ai16z/eliza\";\nimport {\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    IImageDescriptionService,\n    Memory,\n    ModelClass,\n    State,\n    UUID,\n} from \"@ai16z/eliza\";\nimport { stringToUuid } from \"@ai16z/eliza\";\n\nimport { generateMessageResponse, generateShouldRespond } from \"@ai16z/eliza\";\nimport { messageCompletionFooter, shouldRespondFooter } from \"@ai16z/eliza\";\n\nimport { cosineSimilarity } from \"./utils\";\nimport {\n    MESSAGE_CONSTANTS,\n    TIMING_CONSTANTS,\n    RESPONSE_CHANCES,\n    TEAM_COORDINATION\n} from \"./constants\";\n\nconst MAX_MESSAGE_LENGTH = 4096; // Telegram's max message length\n\nconst telegramShouldRespondTemplate =\n    `# About {{agentName}}:\n{{bio}}\n\n# RESPONSE EXAMPLES\n{{user1}}: I just saw a really great movie\n{{user2}}: Oh? Which movie?\nResult: [IGNORE]\n\n{{agentName}}: Oh, this is my favorite scene\n{{user1}}: sick\n{{user2}}: wait, why is it your favorite scene\nResult: [RESPOND]\n\n{{user1}}: stfu bot\nResult: [STOP]\n\n{{user1}}: Hey {{agent}}, can you help me with something\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} stfu plz\nResult: [STOP]\n\n{{user1}}: i need help\n{{agentName}}: how can I help you?\n{{user1}}: no. i need help from someone else\nResult: [IGNORE]\n\n{{user1}}: Hey {{agent}}, can I ask you a question\n{{agentName}}: Sure, what is it\n{{user1}}: can you ask claude to create a basic react module that demonstrates a counter\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} can you tell me a story\n{{agentName}}: uhhh...\n{{user1}}: please do it\n{{agentName}}: okay\n{{agentName}}: once upon a time, in a quaint little village, there was a curious girl named elara\n{{user1}}: I'm loving it, keep going\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} stop responding plz\nResult: [STOP]\n\n{{user1}}: okay, i want to test something. {{agentName}}, can you say marco?\n{{agentName}}: marco\n{{user1}}: great. okay, now do it again\nResult: [RESPOND]\n\nResponse options are [RESPOND], [IGNORE] and [STOP].\n\n{{agentName}} is in a room with other users and should only respond when they are being addressed, and should not respond if they are continuing a conversation that is very long.\n\nRespond with [RESPOND] to messages that are directed at {{agentName}}, or participate in conversations that are interesting or relevant to their background.\nIf a message is not interesting, relevant, or does not directly address {{agentName}}, respond with [IGNORE]\n\nAlso, respond with [IGNORE] to messages that are very short or do not contain much information.\n\nIf a user asks {{agentName}} to be quiet, respond with [STOP]\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, respond with [STOP]\n\nIMPORTANT: {{agentName}} is particularly sensitive about being annoying, so if there is any doubt, it is better to respond with [IGNORE].\nIf {{agentName}} is conversing with a user and they have not asked to stop, it is better to respond with [RESPOND].\n\nThe goal is to decide whether {{agentName}} should respond to the last message.\n\n{{recentMessages}}\n\nThread of Tweets You Are Replying To:\n\n{{formattedConversation}}\n\n# INSTRUCTIONS: Choose the option that best describes {{agentName}}'s response to the last message. Ignore messages if they are addressed to someone else.\n` + shouldRespondFooter;\n\nconst telegramMessageHandlerTemplate =\n    // {{goals}}\n    `# Action Examples\n{{actionExamples}}\n(Action examples are for reference only. Do not use the information from them in your response.)\n\n# Knowledge\n{{knowledge}}\n\n# Task: Generate dialog and actions for the character {{agentName}}.\nAbout {{agentName}}:\n{{bio}}\n{{lore}}\n\nExamples of {{agentName}}'s dialog and actions:\n{{characterMessageExamples}}\n\n{{providers}}\n\n{{attachments}}\n\n{{actions}}\n\n# Capabilities\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\n\n{{messageDirections}}\n\n{{recentMessages}}\n\n# Task: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\nCurrent Post:\n{{currentPost}}\nThread of Tweets You Are Replying To:\n\n{{formattedConversation}}\n` + messageCompletionFooter;\n\ninterface MessageContext {\n    content: string;\n    timestamp: number;\n}\n\nexport type InterestChats = {\n    [key: string]: {\n        currentHandler: string | undefined;\n        lastMessageSent: number;\n        messages: { userId: UUID; userName: string; content: Content }[];\n        previousContext?: MessageContext;\n        contextSimilarityThreshold?: number;\n    };\n};\n\nexport class MessageManager {\n    public bot: Telegraf<Context>;\n    private runtime: IAgentRuntime;\n    private interestChats: InterestChats = {};\n    private teamMemberUsernames: Map<string, string> = new Map();\n\n    constructor(bot: Telegraf<Context>, runtime: IAgentRuntime) {\n        this.bot = bot;\n        this.runtime = runtime;\n\n        this._initializeTeamMemberUsernames().catch(error =>\n            elizaLogger.error(\"Error initializing team member usernames:\", error)\n        );\n    }\n\n    private async _initializeTeamMemberUsernames(): Promise<void> {\n        if (!this.runtime.character.clientConfig?.telegram?.isPartOfTeam) return;\n\n        const teamAgentIds = this.runtime.character.clientConfig.telegram.teamAgentIds || [];\n\n        for (const id of teamAgentIds) {\n            try {\n                const chat = await this.bot.telegram.getChat(id);\n                if ('username' in chat && chat.username) {\n                    this.teamMemberUsernames.set(id, chat.username);\n                    elizaLogger.info(`Cached username for team member ${id}: ${chat.username}`);\n                }\n            } catch (error) {\n                elizaLogger.error(`Error getting username for team member ${id}:`, error);\n            }\n        }\n    }\n\n    private _getTeamMemberUsername(id: string): string | undefined {\n        return this.teamMemberUsernames.get(id);\n    }\n\n    private _getNormalizedUserId(id: string | number): string {\n        return id.toString().replace(/[^0-9]/g, '');\n    }\n\n    private _isTeamMember(userId: string | number): boolean {\n        const teamConfig = this.runtime.character.clientConfig?.telegram;\n        if (!teamConfig?.isPartOfTeam || !teamConfig.teamAgentIds) return false;\n\n        const normalizedUserId = this._getNormalizedUserId(userId);\n        return teamConfig.teamAgentIds.some(teamId =>\n            this._getNormalizedUserId(teamId) === normalizedUserId\n        );\n    }\n\n    private _isTeamLeader(): boolean {\n        return this.bot.botInfo?.id.toString() === this.runtime.character.clientConfig?.telegram?.teamLeaderId;\n    }\n\n    private _isTeamCoordinationRequest(content: string): boolean {\n        const contentLower = content.toLowerCase();\n        return TEAM_COORDINATION.KEYWORDS?.some(keyword =>\n            contentLower.includes(keyword.toLowerCase())\n        );\n    }\n\n    private _isRelevantToTeamMember(content: string, chatId: string, lastAgentMemory: Memory | null = null): boolean {\n        const teamConfig = this.runtime.character.clientConfig?.telegram;\n\n        // Check leader's context based on last message\n        if (this._isTeamLeader() && lastAgentMemory?.content.text) {\n            const timeSinceLastMessage = Date.now() - lastAgentMemory.createdAt;\n            if (timeSinceLastMessage > MESSAGE_CONSTANTS.INTEREST_DECAY_TIME) {\n                return false;\n            }\n\n            const similarity = cosineSimilarity(\n                content.toLowerCase(),\n                lastAgentMemory.content.text.toLowerCase()\n            );\n\n            return similarity >= MESSAGE_CONSTANTS.DEFAULT_SIMILARITY_THRESHOLD_FOLLOW_UPS;\n        }\n\n        // Check team member keywords\n        if (!teamConfig?.teamMemberInterestKeywords?.length) {\n            return false; // If no keywords defined, only leader maintains conversation\n        }\n\n        // Check if content matches any team member keywords\n        return teamConfig.teamMemberInterestKeywords.some(keyword =>\n            content.toLowerCase().includes(keyword.toLowerCase())\n        );\n    }\n\n    private async _analyzeContextSimilarity(currentMessage: string, previousContext?: MessageContext, agentLastMessage?: string): Promise<number> {\n        if (!previousContext) return 1;\n\n        const timeDiff = Date.now() - previousContext.timestamp;\n        const timeWeight = Math.max(0, 1 - (timeDiff / (5 * 60 * 1000)));\n\n        const similarity = cosineSimilarity(\n            currentMessage.toLowerCase(),\n            previousContext.content.toLowerCase(),\n            agentLastMessage?.toLowerCase()\n        );\n\n        return similarity * timeWeight;\n    }\n\n    private async _shouldRespondBasedOnContext(message: Message, chatState: InterestChats[string]): Promise<boolean> {\n        const messageText = 'text' in message ? message.text :\n                           'caption' in message ? (message as any).caption : '';\n\n        if (!messageText) return false;\n\n        // Always respond if mentioned\n        if (this._isMessageForMe(message)) return true;\n\n        // If we're not the current handler, don't respond\n        if (chatState?.currentHandler !== this.bot.botInfo?.id.toString()) return false;\n\n        // Check if we have messages to compare\n        if (!chatState.messages?.length) return false;\n\n        // Get last user message (not from the bot)\n        const lastUserMessage = [...chatState.messages]\n            .reverse()\n            .find((m, index) =>\n                index > 0 && // Skip first message (current)\n                m.userId !== this.runtime.agentId\n            );\n\n        if (!lastUserMessage) return false;\n\n        const lastSelfMemories = await this.runtime.messageManager.getMemories({\n            roomId: stringToUuid(message.chat.id.toString() + \"-\" + this.runtime.agentId),\n            unique: false,\n            count: 5\n        });\n\n        const lastSelfSortedMemories = lastSelfMemories?.filter(m => m.userId === this.runtime.agentId)\n            .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));\n\n        // Calculate context similarity\n        const contextSimilarity = await this._analyzeContextSimilarity(\n            messageText,\n            {\n                content: lastUserMessage.content.text || '',\n                timestamp: Date.now()\n            },\n            lastSelfSortedMemories?.[0]?.content?.text\n        );\n\n        const similarityThreshold =\n            this.runtime.character.clientConfig?.telegram?.messageSimilarityThreshold ||\n            chatState.contextSimilarityThreshold ||\n            MESSAGE_CONSTANTS.DEFAULT_SIMILARITY_THRESHOLD;\n\n        return contextSimilarity >= similarityThreshold;\n    }\n\n    private _isMessageForMe(message: Message): boolean {\n        const botUsername = this.bot.botInfo?.username;\n        if (!botUsername) return false;\n\n        const messageText = 'text' in message ? message.text :\n                           'caption' in message ? (message as any).caption : '';\n        if (!messageText) return false;\n\n        const isReplyToBot = (message as any).reply_to_message?.from?.is_bot === true &&\n                        (message as any).reply_to_message?.from?.username === botUsername;\n        const isMentioned = messageText.includes(`@${botUsername}`);\n        const hasUsername = messageText.toLowerCase().includes(botUsername.toLowerCase());\n\n        return isReplyToBot || isMentioned || (!this.runtime.character.clientConfig?.telegram?.shouldRespondOnlyToMentions && hasUsername);\n    }\n\n\n    private _checkInterest(chatId: string): boolean {\n        const chatState = this.interestChats[chatId];\n        if (!chatState) return false;\n\n        const lastMessage = chatState.messages[chatState.messages.length - 1];\n        const timeSinceLastMessage = Date.now() - chatState.lastMessageSent;\n\n        if (timeSinceLastMessage > MESSAGE_CONSTANTS.INTEREST_DECAY_TIME) {\n            delete this.interestChats[chatId];\n            return false;\n        } else if (timeSinceLastMessage > MESSAGE_CONSTANTS.PARTIAL_INTEREST_DECAY) {\n            return this._isRelevantToTeamMember(lastMessage?.content.text || '', chatId);\n        }\n\n        // Team leader specific checks\n        if (this._isTeamLeader() && chatState.messages.length > 0) {\n            if (!this._isRelevantToTeamMember(lastMessage?.content.text || '', chatId)) {\n                const recentTeamResponses = chatState.messages.slice(-3).some(m =>\n                    m.userId !== this.runtime.agentId &&\n                    this._isTeamMember(m.userId.toString())\n                );\n\n                if (recentTeamResponses) {\n                    delete this.interestChats[chatId];\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    // Process image messages and generate descriptions\n    private async processImage(\n        message: Message\n    ): Promise<{ description: string } | null> {\n        try {\n            let imageUrl: string | null = null;\n\n            elizaLogger.info(`Telegram Message: ${message}`)\n\n            if (\"photo\" in message && message.photo?.length > 0) {\n                const photo = message.photo[message.photo.length - 1];\n                const fileLink = await this.bot.telegram.getFileLink(\n                    photo.file_id\n                );\n                imageUrl = fileLink.toString();\n            } else if (\n                \"document\" in message &&\n                message.document?.mime_type?.startsWith(\"image/\")\n            ) {\n                const fileLink = await this.bot.telegram.getFileLink(\n                    message.document.file_id\n                );\n                imageUrl = fileLink.toString();\n            }\n\n            if (imageUrl) {\n                const imageDescriptionService =\n                    this.runtime.getService<IImageDescriptionService>(\n                        ServiceType.IMAGE_DESCRIPTION\n                    );\n                const { title, description } =\n                    await imageDescriptionService.describeImage(imageUrl);\n                return { description: `[Image: ${title}\\n${description}]` };\n            }\n        } catch (error) {\n            console.error(\"‚ùå Error processing image:\", error);\n        }\n\n        return null;\n    }\n\n    // Decide if the bot should respond to the message\n    private async _shouldRespond(\n        message: Message,\n        state: State\n    ): Promise<boolean> {\n\n        if (this.runtime.character.clientConfig?.telegram?.shouldRespondOnlyToMentions) {\n            return this._isMessageForMe(message);\n        }\n\n        // Respond if bot is mentioned\n        if (\n            \"text\" in message &&\n            message.text?.includes(`@${this.bot.botInfo?.username}`)\n        ) {\n            elizaLogger.info(`Bot mentioned`)\n            return true;\n        }\n\n        // Respond to private chats\n        if (message.chat.type === \"private\") {\n            return true;\n        }\n\n        // Don't respond to images in group chats\n        if (\n            \"photo\" in message ||\n            (\"document\" in message &&\n                message.document?.mime_type?.startsWith(\"image/\"))\n        ) {\n            return false;\n        }\n\n        const chatId = message.chat.id.toString();\n        const chatState = this.interestChats[chatId];\n        const messageText = 'text' in message ? message.text :\n        'caption' in message ? (message as any).caption : '';\n\n        // Check if team member has direct interest first\n        if (this.runtime.character.clientConfig?.discord?.isPartOfTeam &&\n            !this._isTeamLeader() &&\n            this._isRelevantToTeamMember(messageText, chatId)) {\n\n            return true;\n        }\n\n        // Team-based response logic\n        if (this.runtime.character.clientConfig?.telegram?.isPartOfTeam) {\n            // Team coordination\n            if(this._isTeamCoordinationRequest(messageText)) {\n                if (this._isTeamLeader()) {\n                    return true;\n                } else {\n                    const randomDelay = Math.floor(Math.random() * (TIMING_CONSTANTS.TEAM_MEMBER_DELAY_MAX - TIMING_CONSTANTS.TEAM_MEMBER_DELAY_MIN)) +\n                    TIMING_CONSTANTS.TEAM_MEMBER_DELAY_MIN; // 1-3 second random delay\n                    await new Promise(resolve => setTimeout(resolve, randomDelay));\n                    return true;\n                }\n            }\n\n            if (!this._isTeamLeader() && this._isRelevantToTeamMember(messageText, chatId)) {\n                // Add small delay for non-leader responses\n                await new Promise(resolve => setTimeout(resolve, TIMING_CONSTANTS.TEAM_MEMBER_DELAY)); //1.5 second delay\n\n                // If leader has responded in last few seconds, reduce chance of responding\n                if (chatState.messages?.length) {\n                    const recentMessages = chatState.messages.slice(-MESSAGE_CONSTANTS.RECENT_MESSAGE_COUNT);\n                    const leaderResponded = recentMessages.some(m =>\n                        m.userId === this.runtime.character.clientConfig?.telegram?.teamLeaderId &&\n                        Date.now() - chatState.lastMessageSent < 3000\n                    );\n\n                    if (leaderResponded) {\n                        // 50% chance to respond if leader just did\n                        return Math.random() > RESPONSE_CHANCES.AFTER_LEADER;\n                    }\n                }\n\n                return true;\n            }\n\n            // If I'm the leader but message doesn't match my keywords, add delay and check for team responses\n            if (this._isTeamLeader() && !this._isRelevantToTeamMember(messageText, chatId)) {\n                const randomDelay = Math.floor(Math.random() * (TIMING_CONSTANTS.LEADER_DELAY_MAX - TIMING_CONSTANTS.LEADER_DELAY_MIN)) +\n                TIMING_CONSTANTS.LEADER_DELAY_MIN; // 2-4 second random delay\n                await new Promise(resolve => setTimeout(resolve, randomDelay));\n\n                // After delay, check if another team member has already responded\n                if (chatState?.messages?.length) {\n                    const recentResponses = chatState.messages.slice(-MESSAGE_CONSTANTS.RECENT_MESSAGE_COUNT);\n                    const otherTeamMemberResponded = recentResponses.some(m =>\n                        m.userId !== this.runtime.agentId &&\n                        this._isTeamMember(m.userId)\n                    );\n\n                    if (otherTeamMemberResponded) {\n                        return false;\n                    }\n                }\n            }\n\n            // Update current handler if we're mentioned\n            if (this._isMessageForMe(message)) {\n                const channelState = this.interestChats[chatId];\n                if (channelState) {\n                    channelState.currentHandler = this.bot.botInfo?.id.toString()\n                    channelState.lastMessageSent = Date.now();\n                }\n                return true;\n            }\n\n            // Don't respond if another teammate is handling the conversation\n            if (chatState?.currentHandler) {\n                if (chatState.currentHandler !== this.bot.botInfo?.id.toString() &&\n                    this._isTeamMember(chatState.currentHandler)) {\n                    return false;\n                }\n            }\n\n            // Natural conversation cadence\n            if (!this._isMessageForMe(message) && this.interestChats[chatId]) {\n\n                const recentMessages = this.interestChats[chatId].messages\n                    .slice(-MESSAGE_CONSTANTS.CHAT_HISTORY_COUNT);\n                const ourMessageCount = recentMessages.filter(m =>\n                    m.userId === this.runtime.agentId\n                ).length;\n\n                if (ourMessageCount > 2) {\n\n                    const responseChance = Math.pow(0.5, ourMessageCount - 2);\n                    if (Math.random() > responseChance) {\n                        return;\n                    }\n                }\n            }\n\n        }\n\n        // Check context-based response for team conversations\n        if (chatState?.currentHandler) {\n            const shouldRespondContext = await this._shouldRespondBasedOnContext(message, chatState);\n\n            if (!shouldRespondContext) {\n                return false;\n            }\n\n        }\n\n\n        // Use AI to decide for text or captions\n        if (\"text\" in message || (\"caption\" in message && message.caption)) {\n            const shouldRespondContext = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates\n                        ?.telegramShouldRespondTemplate ||\n                    this.runtime.character?.templates?.shouldRespondTemplate ||\n                    telegramShouldRespondTemplate,\n            });\n\n            const response = await generateShouldRespond({\n                runtime: this.runtime,\n                context: shouldRespondContext,\n                modelClass: ModelClass.SMALL,\n            });\n\n            return response === \"RESPOND\";\n        }\n\n        return false;\n    }\n\n    // Send long messages in chunks\n    private async sendMessageInChunks(\n        ctx: Context,\n        content: string,\n        replyToMessageId?: number\n    ): Promise<Message.TextMessage[]> {\n        const chunks = this.splitMessage(content);\n        const sentMessages: Message.TextMessage[] = [];\n\n        for (let i = 0; i < chunks.length; i++) {\n            const chunk = chunks[i];\n            const sentMessage = (await ctx.telegram.sendMessage(\n                ctx.chat.id,\n                chunk,\n                {\n                    reply_parameters:\n                        i === 0 && replyToMessageId\n                            ? { message_id: replyToMessageId }\n                            : undefined,\n                }\n            )) as Message.TextMessage;\n\n            sentMessages.push(sentMessage);\n        }\n\n        return sentMessages;\n    }\n\n    // Split message into smaller parts\n    private splitMessage(text: string): string[] {\n        const chunks: string[] = [];\n        let currentChunk = \"\";\n\n        const lines = text.split(\"\\n\");\n        for (const line of lines) {\n            if (currentChunk.length + line.length + 1 <= MAX_MESSAGE_LENGTH) {\n                currentChunk += (currentChunk ? \"\\n\" : \"\") + line;\n            } else {\n                if (currentChunk) chunks.push(currentChunk);\n                currentChunk = line;\n            }\n        }\n\n        if (currentChunk) chunks.push(currentChunk);\n        return chunks;\n    }\n\n    // Generate a response using AI\n    private async _generateResponse(\n        message: Memory,\n        _state: State,\n        context: string\n    ): Promise<Content> {\n        const { userId, roomId } = message;\n\n        const response = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.LARGE,\n        });\n\n        if (!response) {\n            console.error(\"‚ùå No response from generateMessageResponse\");\n            return null;\n        }\n\n        await this.runtime.databaseAdapter.log({\n            body: { message, context, response },\n            userId,\n            roomId,\n            type: \"response\",\n        });\n\n        return response;\n    }\n\n    // Main handler for incoming messages\n    public async handleMessage(ctx: Context): Promise<void> {\n        if (!ctx.message || !ctx.from) {\n            return; // Exit if no message or sender info\n        }\n\n        if (\n            this.runtime.character.clientConfig?.telegram\n                ?.shouldIgnoreBotMessages &&\n            ctx.from.is_bot\n        ) {\n            return;\n        }\n        if (\n            this.runtime.character.clientConfig?.telegram\n                ?.shouldIgnoreDirectMessages &&\n            ctx.chat?.type === \"private\"\n        ) {\n            return;\n        }\n\n        const message = ctx.message;\n        const chatId = ctx.chat?.id.toString();\n        const messageText = 'text' in message ? message.text :\n                        'caption' in message ? (message as any).caption : '';\n\n        // Add team handling at the start\n        if (this.runtime.character.clientConfig?.telegram?.isPartOfTeam &&\n            !this.runtime.character.clientConfig?.telegram?.shouldRespondOnlyToMentions) {\n\n            const isDirectlyMentioned = this._isMessageForMe(message);\n            const hasInterest = this._checkInterest(chatId);\n\n\n            // Non-leader team member showing interest based on keywords\n            if (!this._isTeamLeader() && this._isRelevantToTeamMember(messageText, chatId)) {\n\n                this.interestChats[chatId] = {\n                    currentHandler: this.bot.botInfo?.id.toString(),\n                    lastMessageSent: Date.now(),\n                    messages: []\n                };\n            }\n\n            const isTeamRequest = this._isTeamCoordinationRequest(messageText);\n            const isLeader = this._isTeamLeader();\n\n\n            // Check for continued interest\n            if (hasInterest && !isDirectlyMentioned) {\n                const lastSelfMemories = await this.runtime.messageManager.getMemories({\n                    roomId: stringToUuid(chatId + \"-\" + this.runtime.agentId),\n                    unique: false,\n                    count: 5\n                });\n\n                const lastSelfSortedMemories = lastSelfMemories?.filter(m => m.userId === this.runtime.agentId)\n                    .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));\n\n                const isRelevant = this._isRelevantToTeamMember(\n                    messageText,\n                    chatId,\n                    lastSelfSortedMemories?.[0]\n                );\n\n                if (!isRelevant) {\n                    delete this.interestChats[chatId];\n                    return;\n                }\n            }\n\n            // Handle team coordination requests\n            if (isTeamRequest) {\n                if (isLeader) {\n                    this.interestChats[chatId] = {\n                        currentHandler: this.bot.botInfo?.id.toString(),\n                        lastMessageSent: Date.now(),\n                        messages: []\n                    };\n                } else {\n                    this.interestChats[chatId] = {\n                        currentHandler: this.bot.botInfo?.id.toString(),\n                        lastMessageSent: Date.now(),\n                        messages: []\n                    };\n\n                    if (!isDirectlyMentioned) {\n                        this.interestChats[chatId].lastMessageSent = 0;\n                    }\n\n                }\n            }\n\n            // Check for other team member mentions using cached usernames\n            const otherTeamMembers = this.runtime.character.clientConfig.telegram.teamAgentIds.filter(\n                id => id !== this.bot.botInfo?.id.toString()\n            );\n\n            const mentionedTeamMember = otherTeamMembers.find(id => {\n                const username = this._getTeamMemberUsername(id);\n                return username && messageText?.includes(`@${username}`);\n            });\n\n            // If another team member is mentioned, clear our interest\n            if (mentionedTeamMember) {\n                if (hasInterest || this.interestChats[chatId]?.currentHandler === this.bot.botInfo?.id.toString()) {\n                    delete this.interestChats[chatId];\n\n                    // Only return if we're not the mentioned member\n                    if (!isDirectlyMentioned) {\n                        return;\n                    }\n                }\n            }\n\n            // Set/maintain interest only if we're mentioned or already have interest\n            if (isDirectlyMentioned) {\n                this.interestChats[chatId] = {\n                    currentHandler: this.bot.botInfo?.id.toString(),\n                    lastMessageSent: Date.now(),\n                    messages: []\n                };\n            } else if (!isTeamRequest && !hasInterest) {\n                return;\n            }\n\n            // Update message tracking\n            if (this.interestChats[chatId]) {\n                this.interestChats[chatId].messages.push({\n                    userId: stringToUuid(ctx.from.id.toString()),\n                    userName: ctx.from.username || ctx.from.first_name || \"Unknown User\",\n                    content: { text: messageText, source: \"telegram\" }\n                });\n\n                if (this.interestChats[chatId].messages.length > MESSAGE_CONSTANTS.MAX_MESSAGES) {\n                    this.interestChats[chatId].messages =\n                        this.interestChats[chatId].messages.slice(-MESSAGE_CONSTANTS.MAX_MESSAGES);\n                }\n            }\n        }\n\n        try {\n            // Convert IDs to UUIDs\n            const userId = stringToUuid(ctx.from.id.toString()) as UUID;\n\n            // Get user name\n            const userName =\n                ctx.from.username || ctx.from.first_name || \"Unknown User\";\n\n            // Get chat ID\n            const chatId = stringToUuid(\n                ctx.chat?.id.toString() + \"-\" + this.runtime.agentId\n            ) as UUID;\n\n            // Get agent ID\n            const agentId = this.runtime.agentId;\n\n            // Get room ID\n            const roomId = chatId;\n\n            // Ensure connection\n            await this.runtime.ensureConnection(\n                userId,\n                roomId,\n                userName,\n                userName,\n                \"telegram\"\n            );\n\n            // Get message ID\n            const messageId = stringToUuid(\n                message.message_id.toString() + \"-\" + this.runtime.agentId\n            ) as UUID;\n\n            // Handle images\n            const imageInfo = await this.processImage(message);\n\n            // Get text or caption\n            let messageText = \"\";\n            if (\"text\" in message) {\n                messageText = message.text;\n            } else if (\"caption\" in message && message.caption) {\n                messageText = message.caption;\n            }\n\n            // Combine text and image description\n            const fullText = imageInfo\n                ? `${messageText} ${imageInfo.description}`\n                : messageText;\n\n            if (!fullText) {\n                return; // Skip if no content\n            }\n\n            // Create content\n            const content: Content = {\n                text: fullText,\n                source: \"telegram\",\n                inReplyTo:\n                    \"reply_to_message\" in message && message.reply_to_message\n                        ? stringToUuid(\n                              message.reply_to_message.message_id.toString() +\n                                  \"-\" +\n                                  this.runtime.agentId\n                          )\n                        : undefined,\n            };\n\n            // Create memory for the message\n            const memory: Memory = {\n                id: messageId,\n                agentId,\n                userId,\n                roomId,\n                content,\n                createdAt: message.date * 1000,\n                embedding: getEmbeddingZeroVector(),\n            };\n\n            // Create memory\n            await this.runtime.messageManager.createMemory(memory);\n\n            // Update state with the new memory\n            let state = await this.runtime.composeState(memory);\n            state = await this.runtime.updateRecentMessageState(state);\n\n            // Decide whether to respond\n            const shouldRespond = await this._shouldRespond(message, state);\n\n            if (shouldRespond) {\n                // Generate response\n                const context = composeContext({\n                    state,\n                    template:\n                        this.runtime.character.templates\n                            ?.telegramMessageHandlerTemplate ||\n                        this.runtime.character?.templates\n                            ?.messageHandlerTemplate ||\n                        telegramMessageHandlerTemplate,\n                });\n\n                const responseContent = await this._generateResponse(\n                    memory,\n                    state,\n                    context\n                );\n\n                if (!responseContent || !responseContent.text) return;\n\n                // Send response in chunks\n                const callback: HandlerCallback = async (content: Content) => {\n                    const sentMessages = await this.sendMessageInChunks(\n                        ctx,\n                        content.text,\n                        message.message_id\n                    );\n\n                    const memories: Memory[] = [];\n\n                    // Create memories for each sent message\n                    for (let i = 0; i < sentMessages.length; i++) {\n                        const sentMessage = sentMessages[i];\n                        const isLastMessage = i === sentMessages.length - 1;\n\n                        const memory: Memory = {\n                            id: stringToUuid(\n                                sentMessage.message_id.toString() +\n                                    \"-\" +\n                                    this.runtime.agentId\n                            ),\n                            agentId,\n                            userId: agentId,\n                            roomId,\n                            content: {\n                                ...content,\n                                text: sentMessage.text,\n                                inReplyTo: messageId,\n                            },\n                            createdAt: sentMessage.date * 1000,\n                            embedding: getEmbeddingZeroVector(),\n                        };\n\n                        // Set action to CONTINUE for all messages except the last one\n                        // For the last message, use the original action from the response content\n                        memory.content.action = !isLastMessage\n                            ? \"CONTINUE\"\n                            : content.action;\n\n                        await this.runtime.messageManager.createMemory(memory);\n                        memories.push(memory);\n                    }\n\n                    return memories;\n                };\n\n                // Execute callback to send messages and log memories\n                const responseMessages = await callback(responseContent);\n\n                // Update state after response\n                state = await this.runtime.updateRecentMessageState(state);\n\n                // Handle any resulting actions\n                await this.runtime.processActions(\n                    memory,\n                    responseMessages,\n                    state,\n                    callback\n                );\n            }\n\n            await this.runtime.evaluate(memory, state, shouldRespond);\n        } catch (error) {\n            elizaLogger.error(\"‚ùå Error handling message:\", error);\n            elizaLogger.error(\"Error sending message:\", error);\n        }\n    }\n}","export function cosineSimilarity(text1: string, text2: string, text3?: string): number {\n    const preprocessText = (text: string) => text\n        .toLowerCase()\n        .replace(/[^\\w\\s'_-]/g, ' ')\n        .replace(/\\s+/g, ' ')\n        .trim();\n\n    const getWords = (text: string) => {\n        return text.split(' ').filter(word => word.length > 1);\n    };\n\n    const words1 = getWords(preprocessText(text1));\n    const words2 = getWords(preprocessText(text2));\n    const words3 = text3 ? getWords(preprocessText(text3)) : [];\n\n    const freq1: { [key: string]: number } = {};\n    const freq2: { [key: string]: number } = {};\n    const freq3: { [key: string]: number } = {};\n\n    words1.forEach(word => freq1[word] = (freq1[word] || 0) + 1);\n    words2.forEach(word => freq2[word] = (freq2[word] || 0) + 1);\n    if (words3.length) {\n        words3.forEach(word => freq3[word] = (freq3[word] || 0) + 1);\n    }\n\n    const uniqueWords = new Set([...Object.keys(freq1), ...Object.keys(freq2), ...(words3.length ? Object.keys(freq3) : [])]);\n\n    let dotProduct = 0;\n    let magnitude1 = 0;\n    let magnitude2 = 0;\n    let magnitude3 = 0;\n\n    uniqueWords.forEach(word => {\n        const val1 = freq1[word] || 0;\n        const val2 = freq2[word] || 0;\n        const val3 = freq3[word] || 0;\n\n        if (words3.length) {\n            // For three-way, calculate pairwise similarities\n            const sim12 = val1 * val2;\n            const sim23 = val2 * val3;\n            const sim13 = val1 * val3;\n\n            // Take maximum similarity between any pair\n            dotProduct += Math.max(sim12, sim23, sim13);\n        } else {\n            dotProduct += val1 * val2;\n        }\n\n        magnitude1 += val1 * val1;\n        magnitude2 += val2 * val2;\n        if (words3.length) {\n            magnitude3 += val3 * val3;\n        }\n    });\n\n    magnitude1 = Math.sqrt(magnitude1);\n    magnitude2 = Math.sqrt(magnitude2);\n    magnitude3 = words3.length ? Math.sqrt(magnitude3) : 1;\n\n    if (magnitude1 === 0 || magnitude2 === 0 || (words3.length && magnitude3 === 0)) return 0;\n\n    // For two texts, use original calculation\n    if (!words3.length) {\n        return dotProduct / (magnitude1 * magnitude2);\n    }\n\n    // For three texts, use max magnitude pair to maintain scale\n    const maxMagnitude = Math.max(\n        magnitude1 * magnitude2,\n        magnitude2 * magnitude3,\n        magnitude1 * magnitude3\n    );\n\n    return dotProduct / maxMagnitude;\n}\n\n/**\n * Splits a message into chunks that fit within Telegram's message length limit\n */\nexport function splitMessage(text: string, maxLength: number = 4096): string[] {\n    const chunks: string[] = [];\n    let currentChunk = \"\";\n\n    const lines = text.split(\"\\n\");\n    for (const line of lines) {\n        if (currentChunk.length + line.length + 1 <= maxLength) {\n            currentChunk += (currentChunk ? \"\\n\" : \"\") + line;\n        } else {\n            if (currentChunk) chunks.push(currentChunk);\n            currentChunk = line;\n        }\n    }\n\n    if (currentChunk) chunks.push(currentChunk);\n    return chunks;\n}","export const MESSAGE_CONSTANTS = {\n    MAX_MESSAGES: 50,\n    RECENT_MESSAGE_COUNT: 5,\n    CHAT_HISTORY_COUNT: 10,\n    DEFAULT_SIMILARITY_THRESHOLD: 0.6,\n    DEFAULT_SIMILARITY_THRESHOLD_FOLLOW_UPS: 0.4,\n    INTEREST_DECAY_TIME: 5 * 60 * 1000, // 5 minutes\n    PARTIAL_INTEREST_DECAY: 3 * 60 * 1000, // 3 minutes\n} as const;\n\nexport const TIMING_CONSTANTS = {\n    TEAM_MEMBER_DELAY: 1500, // 1.5 seconds\n    TEAM_MEMBER_DELAY_MIN: 1000, // 1 second\n    TEAM_MEMBER_DELAY_MAX: 3000, // 3 seconds\n    LEADER_DELAY_MIN: 2000, // 2 seconds\n    LEADER_DELAY_MAX: 4000  // 4 seconds\n} as const;\n\nexport const RESPONSE_CHANCES = {\n    AFTER_LEADER: 0.5,  // 50% chance to respond after leader\n} as const;\n\nexport const TEAM_COORDINATION = {\n    KEYWORDS: [\n        'team',\n        'everyone',\n        'all agents',\n        'team update',\n        'gm team',\n        'hello team',\n        'hey team',\n        'hi team',\n        'morning team',\n        'evening team',\n        'night team',\n        'update team',\n    ]\n} as const;","export async function getOrCreateRecommenderInBe(\n    recommenderId: string,\n    username: string,\n    backendToken: string,\n    backend: string,\n    retries = 3,\n    delayMs = 2000\n) {\n    for (let attempt = 1; attempt <= retries; attempt++) {\n        try {\n            const response = await fetch(\n                `${backend}/api/updaters/getOrCreateRecommender`,\n                {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        Authorization: `Bearer ${backendToken}`,\n                    },\n                    body: JSON.stringify({\n                        recommenderId: recommenderId,\n                        username: username,\n                    }),\n                }\n            );\n            const data = await response.json();\n            return data;\n        } catch (error) {\n            console.error(\n                `Attempt ${attempt} failed: Error getting or creating recommender in backend`,\n                error\n            );\n            if (attempt < retries) {\n                console.log(`Retrying in ${delayMs} ms...`);\n                await new Promise((resolve) => setTimeout(resolve, delayMs));\n            } else {\n                console.error(\"All attempts failed.\");\n            }\n        }\n    }\n}\n","import { IAgentRuntime } from \"@ai16z/eliza\";\nimport { z } from \"zod\";\n\nexport const telegramEnvSchema = z.object({\n    TELEGRAM_BOT_TOKEN: z.string().min(1, \"Telegram bot token is required\"),\n});\n\nexport type TelegramConfig = z.infer<typeof telegramEnvSchema>;\n\nexport async function validateTelegramConfig(\n    runtime: IAgentRuntime\n): Promise<TelegramConfig> {\n    try {\n        const config = {\n            TELEGRAM_BOT_TOKEN:\n                runtime.getSetting(\"TELEGRAM_BOT_TOKEN\") ||\n                process.env.TELEGRAM_BOT_TOKEN,\n        };\n\n        return telegramEnvSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Telegram configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n"],"mappings":";AAAA,SAAS,eAAAA,oBAAmB;;;ACA5B,SAAkB,gBAAgB;AAClC,SAAS,eAAe;AACxB,SAAwB,eAAAC,oBAAmB;;;ACC3C,SAAS,gBAAgB,aAAa,mBAAmB;AACzD,SAAS,8BAA8B;AACvC;AAAA,EAMI;AAAA,OAGG;AACP,SAAS,oBAAoB;AAE7B,SAAS,yBAAyB,6BAA6B;AAC/D,SAAS,yBAAyB,2BAA2B;;;AClBtD,SAAS,iBAAiB,OAAe,OAAe,OAAwB;AACnF,QAAM,iBAAiB,CAAC,SAAiB,KACpC,YAAY,EACZ,QAAQ,eAAe,GAAG,EAC1B,QAAQ,QAAQ,GAAG,EACnB,KAAK;AAEV,QAAM,WAAW,CAAC,SAAiB;AAC/B,WAAO,KAAK,MAAM,GAAG,EAAE,OAAO,UAAQ,KAAK,SAAS,CAAC;AAAA,EACzD;AAEA,QAAM,SAAS,SAAS,eAAe,KAAK,CAAC;AAC7C,QAAM,SAAS,SAAS,eAAe,KAAK,CAAC;AAC7C,QAAM,SAAS,QAAQ,SAAS,eAAe,KAAK,CAAC,IAAI,CAAC;AAE1D,QAAM,QAAmC,CAAC;AAC1C,QAAM,QAAmC,CAAC;AAC1C,QAAM,QAAmC,CAAC;AAE1C,SAAO,QAAQ,UAAQ,MAAM,IAAI,KAAK,MAAM,IAAI,KAAK,KAAK,CAAC;AAC3D,SAAO,QAAQ,UAAQ,MAAM,IAAI,KAAK,MAAM,IAAI,KAAK,KAAK,CAAC;AAC3D,MAAI,OAAO,QAAQ;AACf,WAAO,QAAQ,UAAQ,MAAM,IAAI,KAAK,MAAM,IAAI,KAAK,KAAK,CAAC;AAAA,EAC/D;AAEA,QAAM,cAAc,oBAAI,IAAI,CAAC,GAAG,OAAO,KAAK,KAAK,GAAG,GAAG,OAAO,KAAK,KAAK,GAAG,GAAI,OAAO,SAAS,OAAO,KAAK,KAAK,IAAI,CAAC,CAAE,CAAC;AAExH,MAAI,aAAa;AACjB,MAAI,aAAa;AACjB,MAAI,aAAa;AACjB,MAAI,aAAa;AAEjB,cAAY,QAAQ,UAAQ;AACxB,UAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,UAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,UAAM,OAAO,MAAM,IAAI,KAAK;AAE5B,QAAI,OAAO,QAAQ;AAEf,YAAM,QAAQ,OAAO;AACrB,YAAM,QAAQ,OAAO;AACrB,YAAM,QAAQ,OAAO;AAGrB,oBAAc,KAAK,IAAI,OAAO,OAAO,KAAK;AAAA,IAC9C,OAAO;AACH,oBAAc,OAAO;AAAA,IACzB;AAEA,kBAAc,OAAO;AACrB,kBAAc,OAAO;AACrB,QAAI,OAAO,QAAQ;AACf,oBAAc,OAAO;AAAA,IACzB;AAAA,EACJ,CAAC;AAED,eAAa,KAAK,KAAK,UAAU;AACjC,eAAa,KAAK,KAAK,UAAU;AACjC,eAAa,OAAO,SAAS,KAAK,KAAK,UAAU,IAAI;AAErD,MAAI,eAAe,KAAK,eAAe,KAAM,OAAO,UAAU,eAAe,EAAI,QAAO;AAGxF,MAAI,CAAC,OAAO,QAAQ;AAChB,WAAO,cAAc,aAAa;AAAA,EACtC;AAGA,QAAM,eAAe,KAAK;AAAA,IACtB,aAAa;AAAA,IACb,aAAa;AAAA,IACb,aAAa;AAAA,EACjB;AAEA,SAAO,aAAa;AACxB;;;AC3EO,IAAM,oBAAoB;AAAA,EAC7B,cAAc;AAAA,EACd,sBAAsB;AAAA,EACtB,oBAAoB;AAAA,EACpB,8BAA8B;AAAA,EAC9B,yCAAyC;AAAA,EACzC,qBAAqB,IAAI,KAAK;AAAA;AAAA,EAC9B,wBAAwB,IAAI,KAAK;AAAA;AACrC;AAEO,IAAM,mBAAmB;AAAA,EAC5B,mBAAmB;AAAA;AAAA,EACnB,uBAAuB;AAAA;AAAA,EACvB,uBAAuB;AAAA;AAAA,EACvB,kBAAkB;AAAA;AAAA,EAClB,kBAAkB;AAAA;AACtB;AAEO,IAAM,mBAAmB;AAAA,EAC5B,cAAc;AAAA;AAClB;AAEO,IAAM,oBAAoB;AAAA,EAC7B,UAAU;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ;;;AFTA,IAAM,qBAAqB;AAE3B,IAAM,gCACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAwEA;AAEJ,IAAM;AAAA;AAAA,EAEF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkCA;AAAA;AAiBG,IAAM,iBAAN,MAAqB;AAAA,EACjB;AAAA,EACC;AAAA,EACA,gBAA+B,CAAC;AAAA,EAChC,sBAA2C,oBAAI,IAAI;AAAA,EAE3D,YAAY,KAAwB,SAAwB;AACxD,SAAK,MAAM;AACX,SAAK,UAAU;AAEf,SAAK,+BAA+B,EAAE;AAAA,MAAM,WACxC,YAAY,MAAM,6CAA6C,KAAK;AAAA,IACxE;AAAA,EACJ;AAAA,EAEA,MAAc,iCAAgD;AAC1D,QAAI,CAAC,KAAK,QAAQ,UAAU,cAAc,UAAU,aAAc;AAElE,UAAM,eAAe,KAAK,QAAQ,UAAU,aAAa,SAAS,gBAAgB,CAAC;AAEnF,eAAW,MAAM,cAAc;AAC3B,UAAI;AACA,cAAM,OAAO,MAAM,KAAK,IAAI,SAAS,QAAQ,EAAE;AAC/C,YAAI,cAAc,QAAQ,KAAK,UAAU;AACrC,eAAK,oBAAoB,IAAI,IAAI,KAAK,QAAQ;AAC9C,sBAAY,KAAK,mCAAmC,EAAE,KAAK,KAAK,QAAQ,EAAE;AAAA,QAC9E;AAAA,MACJ,SAAS,OAAO;AACZ,oBAAY,MAAM,0CAA0C,EAAE,KAAK,KAAK;AAAA,MAC5E;AAAA,IACJ;AAAA,EACJ;AAAA,EAEQ,uBAAuB,IAAgC;AAC3D,WAAO,KAAK,oBAAoB,IAAI,EAAE;AAAA,EAC1C;AAAA,EAEQ,qBAAqB,IAA6B;AACtD,WAAO,GAAG,SAAS,EAAE,QAAQ,WAAW,EAAE;AAAA,EAC9C;AAAA,EAEQ,cAAc,QAAkC;AACpD,UAAM,aAAa,KAAK,QAAQ,UAAU,cAAc;AACxD,QAAI,CAAC,YAAY,gBAAgB,CAAC,WAAW,aAAc,QAAO;AAElE,UAAM,mBAAmB,KAAK,qBAAqB,MAAM;AACzD,WAAO,WAAW,aAAa;AAAA,MAAK,YAChC,KAAK,qBAAqB,MAAM,MAAM;AAAA,IAC1C;AAAA,EACJ;AAAA,EAEQ,gBAAyB;AAC7B,WAAO,KAAK,IAAI,SAAS,GAAG,SAAS,MAAM,KAAK,QAAQ,UAAU,cAAc,UAAU;AAAA,EAC9F;AAAA,EAEQ,2BAA2B,SAA0B;AACzD,UAAM,eAAe,QAAQ,YAAY;AACzC,WAAO,kBAAkB,UAAU;AAAA,MAAK,aACpC,aAAa,SAAS,QAAQ,YAAY,CAAC;AAAA,IAC/C;AAAA,EACJ;AAAA,EAEQ,wBAAwB,SAAiB,QAAgB,kBAAiC,MAAe;AAC7G,UAAM,aAAa,KAAK,QAAQ,UAAU,cAAc;AAGxD,QAAI,KAAK,cAAc,KAAK,iBAAiB,QAAQ,MAAM;AACvD,YAAM,uBAAuB,KAAK,IAAI,IAAI,gBAAgB;AAC1D,UAAI,uBAAuB,kBAAkB,qBAAqB;AAC9D,eAAO;AAAA,MACX;AAEA,YAAM,aAAa;AAAA,QACf,QAAQ,YAAY;AAAA,QACpB,gBAAgB,QAAQ,KAAK,YAAY;AAAA,MAC7C;AAEA,aAAO,cAAc,kBAAkB;AAAA,IAC3C;AAGA,QAAI,CAAC,YAAY,4BAA4B,QAAQ;AACjD,aAAO;AAAA,IACX;AAGA,WAAO,WAAW,2BAA2B;AAAA,MAAK,aAC9C,QAAQ,YAAY,EAAE,SAAS,QAAQ,YAAY,CAAC;AAAA,IACxD;AAAA,EACJ;AAAA,EAEA,MAAc,0BAA0B,gBAAwB,iBAAkC,kBAA4C;AAC1I,QAAI,CAAC,gBAAiB,QAAO;AAE7B,UAAM,WAAW,KAAK,IAAI,IAAI,gBAAgB;AAC9C,UAAM,aAAa,KAAK,IAAI,GAAG,IAAK,YAAY,IAAI,KAAK,IAAM;AAE/D,UAAM,aAAa;AAAA,MACf,eAAe,YAAY;AAAA,MAC3B,gBAAgB,QAAQ,YAAY;AAAA,MACpC,kBAAkB,YAAY;AAAA,IAClC;AAEA,WAAO,aAAa;AAAA,EACxB;AAAA,EAEA,MAAc,6BAA6BC,UAAkB,WAAoD;AAC7G,UAAM,cAAc,UAAUA,WAAUA,SAAQ,OAC7B,aAAaA,WAAWA,SAAgB,UAAU;AAErE,QAAI,CAAC,YAAa,QAAO;AAGzB,QAAI,KAAK,gBAAgBA,QAAO,EAAG,QAAO;AAG1C,QAAI,WAAW,mBAAmB,KAAK,IAAI,SAAS,GAAG,SAAS,EAAG,QAAO;AAG1E,QAAI,CAAC,UAAU,UAAU,OAAQ,QAAO;AAGxC,UAAM,kBAAkB,CAAC,GAAG,UAAU,QAAQ,EACzC,QAAQ,EACR;AAAA,MAAK,CAAC,GAAG,UACN,QAAQ;AAAA,MACR,EAAE,WAAW,KAAK,QAAQ;AAAA,IAC9B;AAEJ,QAAI,CAAC,gBAAiB,QAAO;AAE7B,UAAM,mBAAmB,MAAM,KAAK,QAAQ,eAAe,YAAY;AAAA,MACnE,QAAQ,aAAaA,SAAQ,KAAK,GAAG,SAAS,IAAI,MAAM,KAAK,QAAQ,OAAO;AAAA,MAC5E,QAAQ;AAAA,MACR,OAAO;AAAA,IACX,CAAC;AAED,UAAM,yBAAyB,kBAAkB,OAAO,OAAK,EAAE,WAAW,KAAK,QAAQ,OAAO,EACzF,KAAK,CAAC,GAAG,OAAO,EAAE,aAAa,MAAM,EAAE,aAAa,EAAE;AAG3D,UAAM,oBAAoB,MAAM,KAAK;AAAA,MACjC;AAAA,MACA;AAAA,QACI,SAAS,gBAAgB,QAAQ,QAAQ;AAAA,QACzC,WAAW,KAAK,IAAI;AAAA,MACxB;AAAA,MACA,yBAAyB,CAAC,GAAG,SAAS;AAAA,IAC1C;AAEA,UAAM,sBACF,KAAK,QAAQ,UAAU,cAAc,UAAU,8BAC/C,UAAU,8BACV,kBAAkB;AAEtB,WAAO,qBAAqB;AAAA,EAChC;AAAA,EAEQ,gBAAgBA,UAA2B;AAC/C,UAAM,cAAc,KAAK,IAAI,SAAS;AACtC,QAAI,CAAC,YAAa,QAAO;AAEzB,UAAM,cAAc,UAAUA,WAAUA,SAAQ,OAC7B,aAAaA,WAAWA,SAAgB,UAAU;AACrE,QAAI,CAAC,YAAa,QAAO;AAEzB,UAAM,eAAgBA,SAAgB,kBAAkB,MAAM,WAAW,QACxDA,SAAgB,kBAAkB,MAAM,aAAa;AACtE,UAAM,cAAc,YAAY,SAAS,IAAI,WAAW,EAAE;AAC1D,UAAM,cAAc,YAAY,YAAY,EAAE,SAAS,YAAY,YAAY,CAAC;AAEhF,WAAO,gBAAgB,eAAgB,CAAC,KAAK,QAAQ,UAAU,cAAc,UAAU,+BAA+B;AAAA,EAC1H;AAAA,EAGQ,eAAe,QAAyB;AAC5C,UAAM,YAAY,KAAK,cAAc,MAAM;AAC3C,QAAI,CAAC,UAAW,QAAO;AAEvB,UAAM,cAAc,UAAU,SAAS,UAAU,SAAS,SAAS,CAAC;AACpE,UAAM,uBAAuB,KAAK,IAAI,IAAI,UAAU;AAEpD,QAAI,uBAAuB,kBAAkB,qBAAqB;AAC9D,aAAO,KAAK,cAAc,MAAM;AAChC,aAAO;AAAA,IACX,WAAW,uBAAuB,kBAAkB,wBAAwB;AACxE,aAAO,KAAK,wBAAwB,aAAa,QAAQ,QAAQ,IAAI,MAAM;AAAA,IAC/E;AAGA,QAAI,KAAK,cAAc,KAAK,UAAU,SAAS,SAAS,GAAG;AACvD,UAAI,CAAC,KAAK,wBAAwB,aAAa,QAAQ,QAAQ,IAAI,MAAM,GAAG;AACxE,cAAM,sBAAsB,UAAU,SAAS,MAAM,EAAE,EAAE;AAAA,UAAK,OAC1D,EAAE,WAAW,KAAK,QAAQ,WAC1B,KAAK,cAAc,EAAE,OAAO,SAAS,CAAC;AAAA,QAC1C;AAEA,YAAI,qBAAqB;AACrB,iBAAO,KAAK,cAAc,MAAM;AAChC,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA;AAAA,EAGA,MAAc,aACVA,UACuC;AACvC,QAAI;AACA,UAAI,WAA0B;AAE9B,kBAAY,KAAK,qBAAqBA,QAAO,EAAE;AAE/C,UAAI,WAAWA,YAAWA,SAAQ,OAAO,SAAS,GAAG;AACjD,cAAM,QAAQA,SAAQ,MAAMA,SAAQ,MAAM,SAAS,CAAC;AACpD,cAAM,WAAW,MAAM,KAAK,IAAI,SAAS;AAAA,UACrC,MAAM;AAAA,QACV;AACA,mBAAW,SAAS,SAAS;AAAA,MACjC,WACI,cAAcA,YACdA,SAAQ,UAAU,WAAW,WAAW,QAAQ,GAClD;AACE,cAAM,WAAW,MAAM,KAAK,IAAI,SAAS;AAAA,UACrCA,SAAQ,SAAS;AAAA,QACrB;AACA,mBAAW,SAAS,SAAS;AAAA,MACjC;AAEA,UAAI,UAAU;AACV,cAAM,0BACF,KAAK,QAAQ;AAAA,UACT,YAAY;AAAA,QAChB;AACJ,cAAM,EAAE,OAAO,YAAY,IACvB,MAAM,wBAAwB,cAAc,QAAQ;AACxD,eAAO,EAAE,aAAa,WAAW,KAAK;AAAA,EAAK,WAAW,IAAI;AAAA,MAC9D;AAAA,IACJ,SAAS,OAAO;AACZ,cAAQ,MAAM,kCAA6B,KAAK;AAAA,IACpD;AAEA,WAAO;AAAA,EACX;AAAA;AAAA,EAGA,MAAc,eACVA,UACA,OACgB;AAEhB,QAAI,KAAK,QAAQ,UAAU,cAAc,UAAU,6BAA6B;AAC5E,aAAO,KAAK,gBAAgBA,QAAO;AAAA,IACvC;AAGA,QACI,UAAUA,YACVA,SAAQ,MAAM,SAAS,IAAI,KAAK,IAAI,SAAS,QAAQ,EAAE,GACzD;AACE,kBAAY,KAAK,eAAe;AAChC,aAAO;AAAA,IACX;AAGA,QAAIA,SAAQ,KAAK,SAAS,WAAW;AACjC,aAAO;AAAA,IACX;AAGA,QACI,WAAWA,YACV,cAAcA,YACXA,SAAQ,UAAU,WAAW,WAAW,QAAQ,GACtD;AACE,aAAO;AAAA,IACX;AAEA,UAAM,SAASA,SAAQ,KAAK,GAAG,SAAS;AACxC,UAAM,YAAY,KAAK,cAAc,MAAM;AAC3C,UAAM,cAAc,UAAUA,WAAUA,SAAQ,OAChD,aAAaA,WAAWA,SAAgB,UAAU;AAGlD,QAAI,KAAK,QAAQ,UAAU,cAAc,SAAS,gBAC9C,CAAC,KAAK,cAAc,KACpB,KAAK,wBAAwB,aAAa,MAAM,GAAG;AAEnD,aAAO;AAAA,IACX;AAGA,QAAI,KAAK,QAAQ,UAAU,cAAc,UAAU,cAAc;AAE7D,UAAG,KAAK,2BAA2B,WAAW,GAAG;AAC7C,YAAI,KAAK,cAAc,GAAG;AACtB,iBAAO;AAAA,QACX,OAAO;AACH,gBAAM,cAAc,KAAK,MAAM,KAAK,OAAO,KAAK,iBAAiB,wBAAwB,iBAAiB,sBAAsB,IAChI,iBAAiB;AACjB,gBAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,WAAW,CAAC;AAC7D,iBAAO;AAAA,QACX;AAAA,MACJ;AAEA,UAAI,CAAC,KAAK,cAAc,KAAK,KAAK,wBAAwB,aAAa,MAAM,GAAG;AAE5E,cAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,iBAAiB,iBAAiB,CAAC;AAGpF,YAAI,UAAU,UAAU,QAAQ;AAC5B,gBAAM,iBAAiB,UAAU,SAAS,MAAM,CAAC,kBAAkB,oBAAoB;AACvF,gBAAM,kBAAkB,eAAe;AAAA,YAAK,OACxC,EAAE,WAAW,KAAK,QAAQ,UAAU,cAAc,UAAU,gBAC5D,KAAK,IAAI,IAAI,UAAU,kBAAkB;AAAA,UAC7C;AAEA,cAAI,iBAAiB;AAEjB,mBAAO,KAAK,OAAO,IAAI,iBAAiB;AAAA,UAC5C;AAAA,QACJ;AAEA,eAAO;AAAA,MACX;AAGA,UAAI,KAAK,cAAc,KAAK,CAAC,KAAK,wBAAwB,aAAa,MAAM,GAAG;AAC5E,cAAM,cAAc,KAAK,MAAM,KAAK,OAAO,KAAK,iBAAiB,mBAAmB,iBAAiB,iBAAiB,IACtH,iBAAiB;AACjB,cAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,WAAW,CAAC;AAG7D,YAAI,WAAW,UAAU,QAAQ;AAC7B,gBAAM,kBAAkB,UAAU,SAAS,MAAM,CAAC,kBAAkB,oBAAoB;AACxF,gBAAM,2BAA2B,gBAAgB;AAAA,YAAK,OAClD,EAAE,WAAW,KAAK,QAAQ,WAC1B,KAAK,cAAc,EAAE,MAAM;AAAA,UAC/B;AAEA,cAAI,0BAA0B;AAC1B,mBAAO;AAAA,UACX;AAAA,QACJ;AAAA,MACJ;AAGA,UAAI,KAAK,gBAAgBA,QAAO,GAAG;AAC/B,cAAM,eAAe,KAAK,cAAc,MAAM;AAC9C,YAAI,cAAc;AACd,uBAAa,iBAAiB,KAAK,IAAI,SAAS,GAAG,SAAS;AAC5D,uBAAa,kBAAkB,KAAK,IAAI;AAAA,QAC5C;AACA,eAAO;AAAA,MACX;AAGA,UAAI,WAAW,gBAAgB;AAC3B,YAAI,UAAU,mBAAmB,KAAK,IAAI,SAAS,GAAG,SAAS,KAC3D,KAAK,cAAc,UAAU,cAAc,GAAG;AAC9C,iBAAO;AAAA,QACX;AAAA,MACJ;AAGA,UAAI,CAAC,KAAK,gBAAgBA,QAAO,KAAK,KAAK,cAAc,MAAM,GAAG;AAE9D,cAAM,iBAAiB,KAAK,cAAc,MAAM,EAAE,SAC7C,MAAM,CAAC,kBAAkB,kBAAkB;AAChD,cAAM,kBAAkB,eAAe;AAAA,UAAO,OAC1C,EAAE,WAAW,KAAK,QAAQ;AAAA,QAC9B,EAAE;AAEF,YAAI,kBAAkB,GAAG;AAErB,gBAAM,iBAAiB,KAAK,IAAI,KAAK,kBAAkB,CAAC;AACxD,cAAI,KAAK,OAAO,IAAI,gBAAgB;AAChC;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IAEJ;AAGA,QAAI,WAAW,gBAAgB;AAC3B,YAAM,uBAAuB,MAAM,KAAK,6BAA6BA,UAAS,SAAS;AAEvF,UAAI,CAAC,sBAAsB;AACvB,eAAO;AAAA,MACX;AAAA,IAEJ;AAIA,QAAI,UAAUA,YAAY,aAAaA,YAAWA,SAAQ,SAAU;AAChE,YAAM,uBAAuB,eAAe;AAAA,QACxC;AAAA,QACA,UACI,KAAK,QAAQ,UAAU,WACjB,iCACN,KAAK,QAAQ,WAAW,WAAW,yBACnC;AAAA,MACR,CAAC;AAED,YAAM,WAAW,MAAM,sBAAsB;AAAA,QACzC,SAAS,KAAK;AAAA,QACd,SAAS;AAAA,QACT,YAAY,WAAW;AAAA,MAC3B,CAAC;AAED,aAAO,aAAa;AAAA,IACxB;AAEA,WAAO;AAAA,EACX;AAAA;AAAA,EAGA,MAAc,oBACV,KACA,SACA,kBAC8B;AAC9B,UAAM,SAAS,KAAK,aAAa,OAAO;AACxC,UAAM,eAAsC,CAAC;AAE7C,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,YAAM,QAAQ,OAAO,CAAC;AACtB,YAAM,cAAe,MAAM,IAAI,SAAS;AAAA,QACpC,IAAI,KAAK;AAAA,QACT;AAAA,QACA;AAAA,UACI,kBACI,MAAM,KAAK,mBACL,EAAE,YAAY,iBAAiB,IAC/B;AAAA,QACd;AAAA,MACJ;AAEA,mBAAa,KAAK,WAAW;AAAA,IACjC;AAEA,WAAO;AAAA,EACX;AAAA;AAAA,EAGQ,aAAa,MAAwB;AACzC,UAAM,SAAmB,CAAC;AAC1B,QAAI,eAAe;AAEnB,UAAM,QAAQ,KAAK,MAAM,IAAI;AAC7B,eAAW,QAAQ,OAAO;AACtB,UAAI,aAAa,SAAS,KAAK,SAAS,KAAK,oBAAoB;AAC7D,yBAAiB,eAAe,OAAO,MAAM;AAAA,MACjD,OAAO;AACH,YAAI,aAAc,QAAO,KAAK,YAAY;AAC1C,uBAAe;AAAA,MACnB;AAAA,IACJ;AAEA,QAAI,aAAc,QAAO,KAAK,YAAY;AAC1C,WAAO;AAAA,EACX;AAAA;AAAA,EAGA,MAAc,kBACVA,UACA,QACA,SACgB;AAChB,UAAM,EAAE,QAAQ,OAAO,IAAIA;AAE3B,UAAM,WAAW,MAAM,wBAAwB;AAAA,MAC3C,SAAS,KAAK;AAAA,MACd;AAAA,MACA,YAAY,WAAW;AAAA,IAC3B,CAAC;AAED,QAAI,CAAC,UAAU;AACX,cAAQ,MAAM,iDAA4C;AAC1D,aAAO;AAAA,IACX;AAEA,UAAM,KAAK,QAAQ,gBAAgB,IAAI;AAAA,MACnC,MAAM,EAAE,SAAAA,UAAS,SAAS,SAAS;AAAA,MACnC;AAAA,MACA;AAAA,MACA,MAAM;AAAA,IACV,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA,EAGA,MAAa,cAAc,KAA6B;AACpD,QAAI,CAAC,IAAI,WAAW,CAAC,IAAI,MAAM;AAC3B;AAAA,IACJ;AAEA,QACI,KAAK,QAAQ,UAAU,cAAc,UAC/B,2BACN,IAAI,KAAK,QACX;AACE;AAAA,IACJ;AACA,QACI,KAAK,QAAQ,UAAU,cAAc,UAC/B,8BACN,IAAI,MAAM,SAAS,WACrB;AACE;AAAA,IACJ;AAEA,UAAMA,WAAU,IAAI;AACpB,UAAM,SAAS,IAAI,MAAM,GAAG,SAAS;AACrC,UAAM,cAAc,UAAUA,WAAUA,SAAQ,OAChC,aAAaA,WAAWA,SAAgB,UAAU;AAGlE,QAAI,KAAK,QAAQ,UAAU,cAAc,UAAU,gBAC/C,CAAC,KAAK,QAAQ,UAAU,cAAc,UAAU,6BAA6B;AAE7E,YAAM,sBAAsB,KAAK,gBAAgBA,QAAO;AACxD,YAAM,cAAc,KAAK,eAAe,MAAM;AAI9C,UAAI,CAAC,KAAK,cAAc,KAAK,KAAK,wBAAwB,aAAa,MAAM,GAAG;AAE5E,aAAK,cAAc,MAAM,IAAI;AAAA,UACzB,gBAAgB,KAAK,IAAI,SAAS,GAAG,SAAS;AAAA,UAC9C,iBAAiB,KAAK,IAAI;AAAA,UAC1B,UAAU,CAAC;AAAA,QACf;AAAA,MACJ;AAEA,YAAM,gBAAgB,KAAK,2BAA2B,WAAW;AACjE,YAAM,WAAW,KAAK,cAAc;AAIpC,UAAI,eAAe,CAAC,qBAAqB;AACrC,cAAM,mBAAmB,MAAM,KAAK,QAAQ,eAAe,YAAY;AAAA,UACnE,QAAQ,aAAa,SAAS,MAAM,KAAK,QAAQ,OAAO;AAAA,UACxD,QAAQ;AAAA,UACR,OAAO;AAAA,QACX,CAAC;AAED,cAAM,yBAAyB,kBAAkB,OAAO,OAAK,EAAE,WAAW,KAAK,QAAQ,OAAO,EACzF,KAAK,CAAC,GAAG,OAAO,EAAE,aAAa,MAAM,EAAE,aAAa,EAAE;AAE3D,cAAM,aAAa,KAAK;AAAA,UACpB;AAAA,UACA;AAAA,UACA,yBAAyB,CAAC;AAAA,QAC9B;AAEA,YAAI,CAAC,YAAY;AACb,iBAAO,KAAK,cAAc,MAAM;AAChC;AAAA,QACJ;AAAA,MACJ;AAGA,UAAI,eAAe;AACf,YAAI,UAAU;AACV,eAAK,cAAc,MAAM,IAAI;AAAA,YACzB,gBAAgB,KAAK,IAAI,SAAS,GAAG,SAAS;AAAA,YAC9C,iBAAiB,KAAK,IAAI;AAAA,YAC1B,UAAU,CAAC;AAAA,UACf;AAAA,QACJ,OAAO;AACH,eAAK,cAAc,MAAM,IAAI;AAAA,YACzB,gBAAgB,KAAK,IAAI,SAAS,GAAG,SAAS;AAAA,YAC9C,iBAAiB,KAAK,IAAI;AAAA,YAC1B,UAAU,CAAC;AAAA,UACf;AAEA,cAAI,CAAC,qBAAqB;AACtB,iBAAK,cAAc,MAAM,EAAE,kBAAkB;AAAA,UACjD;AAAA,QAEJ;AAAA,MACJ;AAGA,YAAM,mBAAmB,KAAK,QAAQ,UAAU,aAAa,SAAS,aAAa;AAAA,QAC/E,QAAM,OAAO,KAAK,IAAI,SAAS,GAAG,SAAS;AAAA,MAC/C;AAEA,YAAM,sBAAsB,iBAAiB,KAAK,QAAM;AACpD,cAAM,WAAW,KAAK,uBAAuB,EAAE;AAC/C,eAAO,YAAY,aAAa,SAAS,IAAI,QAAQ,EAAE;AAAA,MAC3D,CAAC;AAGD,UAAI,qBAAqB;AACrB,YAAI,eAAe,KAAK,cAAc,MAAM,GAAG,mBAAmB,KAAK,IAAI,SAAS,GAAG,SAAS,GAAG;AAC/F,iBAAO,KAAK,cAAc,MAAM;AAGhC,cAAI,CAAC,qBAAqB;AACtB;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAGA,UAAI,qBAAqB;AACrB,aAAK,cAAc,MAAM,IAAI;AAAA,UACzB,gBAAgB,KAAK,IAAI,SAAS,GAAG,SAAS;AAAA,UAC9C,iBAAiB,KAAK,IAAI;AAAA,UAC1B,UAAU,CAAC;AAAA,QACf;AAAA,MACJ,WAAW,CAAC,iBAAiB,CAAC,aAAa;AACvC;AAAA,MACJ;AAGA,UAAI,KAAK,cAAc,MAAM,GAAG;AAC5B,aAAK,cAAc,MAAM,EAAE,SAAS,KAAK;AAAA,UACrC,QAAQ,aAAa,IAAI,KAAK,GAAG,SAAS,CAAC;AAAA,UAC3C,UAAU,IAAI,KAAK,YAAY,IAAI,KAAK,cAAc;AAAA,UACtD,SAAS,EAAE,MAAM,aAAa,QAAQ,WAAW;AAAA,QACrD,CAAC;AAED,YAAI,KAAK,cAAc,MAAM,EAAE,SAAS,SAAS,kBAAkB,cAAc;AAC7E,eAAK,cAAc,MAAM,EAAE,WACvB,KAAK,cAAc,MAAM,EAAE,SAAS,MAAM,CAAC,kBAAkB,YAAY;AAAA,QACjF;AAAA,MACJ;AAAA,IACJ;AAEA,QAAI;AAEA,YAAM,SAAS,aAAa,IAAI,KAAK,GAAG,SAAS,CAAC;AAGlD,YAAM,WACF,IAAI,KAAK,YAAY,IAAI,KAAK,cAAc;AAGhD,YAAMC,UAAS;AAAA,QACX,IAAI,MAAM,GAAG,SAAS,IAAI,MAAM,KAAK,QAAQ;AAAA,MACjD;AAGA,YAAM,UAAU,KAAK,QAAQ;AAG7B,YAAM,SAASA;AAGf,YAAM,KAAK,QAAQ;AAAA,QACf;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAGA,YAAM,YAAY;AAAA,QACdD,SAAQ,WAAW,SAAS,IAAI,MAAM,KAAK,QAAQ;AAAA,MACvD;AAGA,YAAM,YAAY,MAAM,KAAK,aAAaA,QAAO;AAGjD,UAAIE,eAAc;AAClB,UAAI,UAAUF,UAAS;AACnB,QAAAE,eAAcF,SAAQ;AAAA,MAC1B,WAAW,aAAaA,YAAWA,SAAQ,SAAS;AAChD,QAAAE,eAAcF,SAAQ;AAAA,MAC1B;AAGA,YAAM,WAAW,YACX,GAAGE,YAAW,IAAI,UAAU,WAAW,KACvCA;AAEN,UAAI,CAAC,UAAU;AACX;AAAA,MACJ;AAGA,YAAM,UAAmB;AAAA,QACrB,MAAM;AAAA,QACN,QAAQ;AAAA,QACR,WACI,sBAAsBF,YAAWA,SAAQ,mBACnC;AAAA,UACIA,SAAQ,iBAAiB,WAAW,SAAS,IACzC,MACA,KAAK,QAAQ;AAAA,QACrB,IACA;AAAA,MACd;AAGA,YAAM,SAAiB;AAAA,QACnB,IAAI;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,WAAWA,SAAQ,OAAO;AAAA,QAC1B,WAAW,uBAAuB;AAAA,MACtC;AAGA,YAAM,KAAK,QAAQ,eAAe,aAAa,MAAM;AAGrD,UAAI,QAAQ,MAAM,KAAK,QAAQ,aAAa,MAAM;AAClD,cAAQ,MAAM,KAAK,QAAQ,yBAAyB,KAAK;AAGzD,YAAM,gBAAgB,MAAM,KAAK,eAAeA,UAAS,KAAK;AAE9D,UAAI,eAAe;AAEf,cAAM,UAAU,eAAe;AAAA,UAC3B;AAAA,UACA,UACI,KAAK,QAAQ,UAAU,WACjB,kCACN,KAAK,QAAQ,WAAW,WAClB,0BACN;AAAA,QACR,CAAC;AAED,cAAM,kBAAkB,MAAM,KAAK;AAAA,UAC/B;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAEA,YAAI,CAAC,mBAAmB,CAAC,gBAAgB,KAAM;AAG/C,cAAM,WAA4B,OAAOG,aAAqB;AAC1D,gBAAM,eAAe,MAAM,KAAK;AAAA,YAC5B;AAAA,YACAA,SAAQ;AAAA,YACRH,SAAQ;AAAA,UACZ;AAEA,gBAAM,WAAqB,CAAC;AAG5B,mBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,kBAAM,cAAc,aAAa,CAAC;AAClC,kBAAM,gBAAgB,MAAM,aAAa,SAAS;AAElD,kBAAMI,UAAiB;AAAA,cACnB,IAAI;AAAA,gBACA,YAAY,WAAW,SAAS,IAC5B,MACA,KAAK,QAAQ;AAAA,cACrB;AAAA,cACA;AAAA,cACA,QAAQ;AAAA,cACR;AAAA,cACA,SAAS;AAAA,gBACL,GAAGD;AAAA,gBACH,MAAM,YAAY;AAAA,gBAClB,WAAW;AAAA,cACf;AAAA,cACA,WAAW,YAAY,OAAO;AAAA,cAC9B,WAAW,uBAAuB;AAAA,YACtC;AAIA,YAAAC,QAAO,QAAQ,SAAS,CAAC,gBACnB,aACAD,SAAQ;AAEd,kBAAM,KAAK,QAAQ,eAAe,aAAaC,OAAM;AACrD,qBAAS,KAAKA,OAAM;AAAA,UACxB;AAEA,iBAAO;AAAA,QACX;AAGA,cAAM,mBAAmB,MAAM,SAAS,eAAe;AAGvD,gBAAQ,MAAM,KAAK,QAAQ,yBAAyB,KAAK;AAGzD,cAAM,KAAK,QAAQ;AAAA,UACf;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAEA,YAAM,KAAK,QAAQ,SAAS,QAAQ,OAAO,aAAa;AAAA,IAC5D,SAAS,OAAO;AACZ,kBAAY,MAAM,kCAA6B,KAAK;AACpD,kBAAY,MAAM,0BAA0B,KAAK;AAAA,IACrD;AAAA,EACJ;AACJ;;;AG38BA,eAAsB,2BAClB,eACA,UACA,cACA,SACA,UAAU,GACV,UAAU,KACZ;AACE,WAAS,UAAU,GAAG,WAAW,SAAS,WAAW;AACjD,QAAI;AACA,YAAM,WAAW,MAAM;AAAA,QACnB,GAAG,OAAO;AAAA,QACV;AAAA,UACI,QAAQ;AAAA,UACR,SAAS;AAAA,YACL,gBAAgB;AAAA,YAChB,eAAe,UAAU,YAAY;AAAA,UACzC;AAAA,UACA,MAAM,KAAK,UAAU;AAAA,YACjB;AAAA,YACA;AAAA,UACJ,CAAC;AAAA,QACL;AAAA,MACJ;AACA,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,cAAQ;AAAA,QACJ,WAAW,OAAO;AAAA,QAClB;AAAA,MACJ;AACA,UAAI,UAAU,SAAS;AACnB,gBAAQ,IAAI,eAAe,OAAO,QAAQ;AAC1C,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,OAAO,CAAC;AAAA,MAC/D,OAAO;AACH,gBAAQ,MAAM,sBAAsB;AAAA,MACxC;AAAA,IACJ;AAAA,EACJ;AACJ;;;AJjCO,IAAM,iBAAN,MAAqB;AAAA,EAChB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,SAAwB,UAAkB;AAClD,IAAAC,aAAY,IAAI,8CAAuC;AACvD,SAAK,UAAU;AACf,SAAK,MAAM,IAAI,SAAS,QAAQ;AAChC,SAAK,iBAAiB,IAAI,eAAe,KAAK,KAAK,KAAK,OAAO;AAC/D,SAAK,UAAU,QAAQ,WAAW,aAAa;AAC/C,SAAK,eAAe,QAAQ,WAAW,eAAe;AACtD,SAAK,WAAW,QAAQ,WAAW,WAAW;AAC9C,IAAAA,aAAY,IAAI,6CAAwC;AAAA,EAC5D;AAAA,EAEA,MAAa,QAAuB;AAChC,IAAAA,aAAY,IAAI,oCAA6B;AAC7C,QAAI;AACA,YAAM,KAAK,cAAc;AACzB,WAAK,qBAAqB;AAC1B,WAAK,sBAAsB;AAAA,IAC/B,SAAS,OAAO;AACZ,MAAAA,aAAY,MAAM,yCAAoC,KAAK;AAC3D,YAAM;AAAA,IACV;AAAA,EACJ;AAAA,EAEA,MAAc,gBAA+B;AACzC,SAAK,IAAI,OAAO,EAAE,oBAAoB,KAAK,CAAC;AAC5C,IAAAA,aAAY;AAAA,MACR;AAAA,IACJ;AAEA,UAAM,UAAU,MAAM,KAAK,IAAI,SAAS,MAAM;AAC9C,SAAK,IAAI,UAAU;AACnB,IAAAA,aAAY,QAAQ,kBAAkB,QAAQ,QAAQ,EAAE;AAExD,SAAK,eAAe,MAAM,KAAK;AAAA,EACnC;AAAA,EAEA,MAAc,kBAAkB,KAAgC;AAC5D,UAAM,SAAS,KAAK,QAAQ,UAAU,cAAc;AACpD,QAAI,IAAI,MAAM,OAAO,IAAI,SAAS,IAAI;AAClC,aAAO;AAAA,IACX;AAEA,QAAI,CAAC,QAAQ,+BAA+B;AACxC,aAAO;AAAA,IACX;AAEA,UAAM,gBAAgB,OAAO,mBAAmB,CAAC;AACjD,UAAM,iBAAiB,IAAI,KAAK,GAAG,SAAS;AAE5C,QAAI,CAAC,cAAc,SAAS,cAAc,GAAG;AACzC,MAAAA,aAAY,KAAK,gCAAgC,cAAc,EAAE;AACjE,UAAI;AACA,cAAM,IAAI,MAAM,0BAA0B;AAC1C,cAAM,IAAI,UAAU;AAAA,MACxB,SAAS,OAAO;AACZ,QAAAA,aAAY,MAAM,oCAAoC,cAAc,KAAK,KAAK;AAAA,MAClF;AACA,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEQ,uBAA6B;AACjC,IAAAA,aAAY,IAAI,+BAA+B;AAE/C,SAAK,IAAI,GAAG,QAAQ,kBAAkB,GAAG,OAAO,QAAQ;AACpD,UAAI;AACA,cAAM,aAAa,IAAI,QAAQ;AAC/B,cAAM,aAAa,WAAW,KAAK,YAAU,OAAO,OAAO,IAAI,QAAQ,EAAE;AAEzE,YAAI,cAAc,CAAE,MAAM,KAAK,kBAAkB,GAAG,GAAI;AACpD;AAAA,QACJ;AAAA,MACJ,SAAS,OAAO;AACZ,QAAAA,aAAY,MAAM,oCAAoC,KAAK;AAAA,MAC/D;AAAA,IACJ,CAAC;AAED,SAAK,IAAI,GAAG,WAAW,OAAO,QAAQ;AAClC,UAAI;AAEA,YAAI,CAAE,MAAM,KAAK,kBAAkB,GAAG,GAAI;AACtC;AAAA,QACJ;AAEA,YAAI,KAAK,UAAU;AACf,gBAAM,SAAS,IAAI,MAAM,GAAG,SAAS;AACrC,gBAAM,WACF,IAAI,MAAM,YAAY,IAAI,MAAM,cAAc;AAClD,cAAI,CAAC,QAAQ;AACT,YAAAA,aAAY;AAAA,cACR;AAAA,YACJ;AACA;AAAA,UACJ;AACA,cAAI;AACA,kBAAM;AAAA,cACF;AAAA,cACA;AAAA,cACA,KAAK;AAAA,cACL,KAAK;AAAA,YACT;AAAA,UACJ,SAAS,OAAO;AACZ,YAAAA,aAAY;AAAA,cACR;AAAA,cACA;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAEA,cAAM,KAAK,eAAe,cAAc,GAAG;AAAA,MAC/C,SAAS,OAAO;AACZ,QAAAA,aAAY,MAAM,kCAA6B,KAAK;AAEpD,YAAI,OAAO,UAAU,eAAe,KAAK;AACrC,cAAI;AACA,kBAAM,IAAI,MAAM,kDAAkD;AAAA,UACtE,SAAS,YAAY;AACjB,YAAAA,aAAY,MAAM,iCAAiC,UAAU;AAAA,UACjE;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC;AAED,SAAK,IAAI,GAAG,SAAS,CAAC,QAAQ;AAC1B,MAAAA,aAAY;AAAA,QACR;AAAA,QACA,IAAI,QAAQ;AAAA,MAChB;AAAA,IACJ,CAAC;AAED,SAAK,IAAI,GAAG,YAAY,CAAC,QAAQ;AAC7B,MAAAA,aAAY;AAAA,QACR;AAAA,QACA,IAAI,QAAQ,SAAS;AAAA,MACzB;AAAA,IACJ,CAAC;AAED,SAAK,IAAI,MAAM,CAAC,KAAK,QAAQ;AACzB,MAAAA,aAAY,MAAM,6BAAwB,IAAI,UAAU,KAAK,GAAG;AAChE,UAAI,MAAM,uDAAuD;AAAA,IACrE,CAAC;AAAA,EACL;AAAA,EAEQ,wBAA8B;AAClC,UAAM,kBAAkB,OAAO,WAAmB;AAC9C,MAAAA,aAAY;AAAA,QACR,yBAAe,MAAM;AAAA,MACzB;AACA,UAAI;AACA,cAAM,KAAK,KAAK;AAChB,QAAAA,aAAY,IAAI,2CAAoC;AAAA,MACxD,SAAS,OAAO;AACZ,QAAAA,aAAY;AAAA,UACR;AAAA,UACA;AAAA,QACJ;AACA,cAAM;AAAA,MACV;AAAA,IACJ;AAEA,YAAQ,KAAK,UAAU,MAAM,gBAAgB,QAAQ,CAAC;AACtD,YAAQ,KAAK,WAAW,MAAM,gBAAgB,SAAS,CAAC;AACxD,YAAQ,KAAK,UAAU,MAAM,gBAAgB,QAAQ,CAAC;AAAA,EAC1D;AAAA,EAEA,MAAa,OAAsB;AAC/B,IAAAA,aAAY,IAAI,0BAA0B;AAC1C,UAAM,KAAK,IAAI,KAAK;AACpB,IAAAA,aAAY,IAAI,sBAAsB;AAAA,EAC1C;AACJ;;;AKzLA,SAAS,SAAS;AAEX,IAAM,oBAAoB,EAAE,OAAO;AAAA,EACtC,oBAAoB,EAAE,OAAO,EAAE,IAAI,GAAG,gCAAgC;AAC1E,CAAC;AAID,eAAsB,uBAClB,SACuB;AACvB,MAAI;AACA,UAAM,SAAS;AAAA,MACX,oBACI,QAAQ,WAAW,oBAAoB,KACvC,QAAQ,IAAI;AAAA,IACpB;AAEA,WAAO,kBAAkB,MAAM,MAAM;AAAA,EACzC,SAAS,OAAO;AACZ,QAAI,iBAAiB,EAAE,UAAU;AAC7B,YAAM,gBAAgB,MAAM,OACvB,IAAI,CAAC,QAAQ,GAAG,IAAI,KAAK,KAAK,GAAG,CAAC,KAAK,IAAI,OAAO,EAAE,EACpD,KAAK,IAAI;AACd,YAAM,IAAI;AAAA,QACN;AAAA,EAA8C,aAAa;AAAA,MAC/D;AAAA,IACJ;AACA,UAAM;AAAA,EACV;AACJ;;;AN1BO,IAAM,0BAAkC;AAAA,EAC3C,OAAO,OAAO,YAA2B;AACrC,UAAM,uBAAuB,OAAO;AAEpC,UAAM,KAAK,IAAI;AAAA,MACX;AAAA,MACA,QAAQ,WAAW,oBAAoB;AAAA,IAC3C;AAEA,UAAM,GAAG,MAAM;AAEf,IAAAC,aAAY;AAAA,MACR,6DAAwD,QAAQ,UAAU,IAAI;AAAA,IAClF;AACA,WAAO;AAAA,EACX;AAAA,EACA,MAAM,OAAO,aAA4B;AACrC,IAAAA,aAAY,KAAK,+CAA+C;AAAA,EACpE;AACJ;AAEA,IAAO,cAAQ;","names":["elizaLogger","elizaLogger","message","chatId","messageText","content","memory","elizaLogger","elizaLogger"]}