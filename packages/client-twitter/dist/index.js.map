{"version":3,"sources":["../src/post.ts","../src/utils.ts","../src/environment.ts","../src/interactions.ts","../src/search.ts","../src/index.ts","../src/base.ts"],"sourcesContent":["import { Tweet } from \"agent-twitter-client\";\nimport {\n    composeContext,\n    generateText,\n    getEmbeddingZeroVector,\n    IAgentRuntime,\n    ModelClass,\n    stringToUuid,\n    parseBooleanFromText,\n} from \"@ai16z/eliza\";\nimport { elizaLogger } from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base.ts\";\nimport { postActionResponseFooter } from \"@ai16z/eliza\";\nimport { generateTweetActions } from \"@ai16z/eliza\";\nimport { IImageDescriptionService, ServiceType } from \"@ai16z/eliza\";\nimport { buildConversationThread } from \"./utils.ts\";\nimport { twitterMessageHandlerTemplate } from \"./interactions.ts\";\n\nconst twitterPostTemplate = `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\n# Task: Generate a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.\nWrite a 1-3 sentence post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than {{maxTweetLength}}. No emojis. Use \\\\n\\\\n (double spaces) between statements.`;\n\nexport const twitterActionTemplate = `\n# INSTRUCTIONS: Determine actions for {{agentName}} (@{{twitterUserName}}) based on:\n{{bio}}\n{{postDirections}}\n\nGuidelines:\n- Highly selective engagement\n- Direct mentions are priority\n- Skip: low-effort content, off-topic, repetitive\n\nActions (respond only with tags):\n[LIKE] - Resonates with interests (9.5/10)\n[RETWEET] - Perfect character alignment (9/10)\n[QUOTE] - Can add unique value (8/10)\n[REPLY] - Memetic opportunity (9/10)\n\nTweet:\n{{currentTweet}}\n\n# Respond with qualifying action tags only.`\n    + postActionResponseFooter;\n\nconst MAX_TWEET_LENGTH = 240;\n\n/**\n * Truncate text to fit within the Twitter character limit, ensuring it ends at a complete sentence.\n */\nfunction truncateToCompleteSentence(\n    text: string,\n    maxTweetLength: number\n): string {\n    if (text.length <= maxTweetLength) {\n        return text;\n    }\n\n    // Attempt to truncate at the last period within the limit\n    const truncatedAtPeriod = text.slice(\n        0,\n        text.lastIndexOf(\".\", maxTweetLength) + 1\n    );\n    if (truncatedAtPeriod.trim().length > 0) {\n        return truncatedAtPeriod.trim();\n    }\n\n    // If no period is found, truncate to the nearest whitespace\n    const truncatedAtSpace = text.slice(\n        0,\n        text.lastIndexOf(\" \", maxTweetLength)\n    );\n    if (truncatedAtSpace.trim().length > 0) {\n        return truncatedAtSpace.trim() + \"...\";\n    }\n\n    // Fallback: Hard truncate and add ellipsis\n    return text.slice(0, maxTweetLength - 3).trim() + \"...\";\n}\n\n\nexport class TwitterPostClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    twitterUsername: string;\n    private isProcessing: boolean = false;\n    private lastProcessTime: number = 0;\n    private stopProcessingActions: boolean = false;\n\n\n    async start(postImmediately: boolean = false) {\n        if (!this.client.profile) {\n            await this.client.init();\n        }\n\n        const generateNewTweetLoop = async () => {\n            const lastPost = await this.runtime.cacheManager.get<{\n                timestamp: number;\n            }>(\n                \"twitter/\" +\n                    this.twitterUsername +\n                    \"/lastPost\"\n            );\n\n            const lastPostTimestamp = lastPost?.timestamp ?? 0;\n            const minMinutes =\n                parseInt(this.runtime.getSetting(\"POST_INTERVAL_MIN\")) || 90;\n            const maxMinutes =\n                parseInt(this.runtime.getSetting(\"POST_INTERVAL_MAX\")) || 180;\n            const randomMinutes =\n                Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) +\n                minMinutes;\n            const delay = randomMinutes * 60 * 1000;\n\n            if (Date.now() > lastPostTimestamp + delay) {\n                await this.generateNewTweet();\n            }\n\n            setTimeout(() => {\n                generateNewTweetLoop(); // Set up next iteration\n            }, delay);\n\n            elizaLogger.log(`Next tweet scheduled in ${randomMinutes} minutes`);\n        };\n\n        const processActionsLoop = async () => {\n            const actionInterval = parseInt(\n                this.runtime.getSetting(\"ACTION_INTERVAL\")\n            ) || 300000; // Default to 5 minutes\n\n            while (!this.stopProcessingActions) {\n                try {\n                    const results = await this.processTweetActions();\n                    if (results) {\n                        elizaLogger.log(`Processed ${results.length} tweets`);\n                        elizaLogger.log(`Next action processing scheduled in ${actionInterval / 1000} seconds`);\n                        // Wait for the full interval before next processing\n                        await new Promise(resolve => setTimeout(resolve, actionInterval));\n                    }\n                } catch (error) {\n                    elizaLogger.error(\"Error in action processing loop:\", error);\n                    // Add exponential backoff on error\n                    await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30s on error\n                }\n            }\n        };\n\n        if (\n            this.runtime.getSetting(\"POST_IMMEDIATELY\") != null &&\n            this.runtime.getSetting(\"POST_IMMEDIATELY\") != \"\"\n        ) {\n            postImmediately = parseBooleanFromText(\n                this.runtime.getSetting(\"POST_IMMEDIATELY\")\n            );\n        }\n\n        if (postImmediately) {\n            await this.generateNewTweet();\n        }\n        generateNewTweetLoop();\n\n        // Add check for ENABLE_ACTION_PROCESSING before starting the loop\n        const enableActionProcessing = parseBooleanFromText(\n            this.runtime.getSetting(\"ENABLE_ACTION_PROCESSING\") ?? \"true\"\n        );\n\n        if (enableActionProcessing) {\n            processActionsLoop().catch(error => {\n                elizaLogger.error(\"Fatal error in process actions loop:\", error);\n            });\n        } else {\n            elizaLogger.log(\"Action processing loop disabled by configuration\");\n        }\n        generateNewTweetLoop();\n    }\n\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.twitterUsername = runtime.getSetting(\"TWITTER_USERNAME\");\n    }\n\n    private async generateNewTweet() {\n        elizaLogger.log(\"Generating new tweet\");\n\n        try {\n            const roomId = stringToUuid(\n                \"twitter_generate_room-\" + this.client.profile.username\n            );\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                this.client.profile.username,\n                this.runtime.character.name,\n                \"twitter\"\n            );\n\n            const topics = this.runtime.character.topics.join(\", \");\n\n            const state = await this.runtime.composeState(\n                {\n                    userId: this.runtime.agentId,\n                    roomId: roomId,\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: topics || '',\n                        action: \"TWEET\",\n                    },\n                },\n                {\n                    twitterUserName: this.client.profile.username,\n                }\n            );\n\n            const context = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.twitterPostTemplate ||\n                    twitterPostTemplate,\n            });\n\n            elizaLogger.debug(\"generate post prompt:\\n\" + context);\n\n            const newTweetContent = await generateText({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            // First attempt to clean content\n            let cleanedContent = '';\n\n            // Try parsing as JSON first\n            try {\n                const parsedResponse = JSON.parse(newTweetContent);\n                if (parsedResponse.text) {\n                    cleanedContent = parsedResponse.text;\n                } else if (typeof parsedResponse === 'string') {\n                    cleanedContent = parsedResponse;\n                }\n            } catch (error) {\n                error.linted = true; // make linter happy since catch needs a variable\n                // If not JSON, clean the raw content\n                cleanedContent = newTweetContent\n                    .replace(/^\\s*{?\\s*\"text\":\\s*\"|\"\\s*}?\\s*$/g, '') // Remove JSON-like wrapper\n                    .replace(/^['\"](.*)['\"]$/g, '$1')  // Remove quotes\n                    .replace(/\\\\\"/g, '\"')  // Unescape quotes\n                    .replace(/\\\\n/g, '\\n') // Unescape newlines\n                    .trim();\n            }\n\n            if (!cleanedContent) {\n                elizaLogger.error('Failed to extract valid content from response:', {\n                    rawResponse: newTweetContent,\n                    attempted: 'JSON parsing'\n                });\n                return;\n            }\n\n            // Use the helper function to truncate to complete sentence\n            const content = truncateToCompleteSentence(cleanedContent, MAX_TWEET_LENGTH);\n\n            const removeQuotes = (str: string) =>\n                str.replace(/^['\"](.*)['\"]$/, \"$1\");\n\n            const fixNewLines = (str: string) =>\n                str.replaceAll(/\\\\n/g, \"\\n\");\n\n            // Final cleaning\n            cleanedContent = removeQuotes(fixNewLines(content));\n\n            if (this.runtime.getSetting(\"TWITTER_DRY_RUN\") === \"true\") {\n                elizaLogger.info(\n                    `Dry run: would have posted tweet: ${cleanedContent}`\n                );\n                return;\n            }\n\n            try {\n                elizaLogger.log(`Posting new tweet:\\n ${cleanedContent}`);\n\n                const result = await this.client.requestQueue.add(\n                    async () =>\n                        await this.client.twitterClient.sendTweet(cleanedContent)\n                );\n                const body = await result.json();\n                if (!body?.data?.create_tweet?.tweet_results?.result) {\n                    console.error(\"Error sending tweet; Bad response:\", body);\n                    return;\n                }\n                const tweetResult = body.data.create_tweet.tweet_results.result;\n\n                const tweet = {\n                    id: tweetResult.rest_id,\n                    name: this.client.profile.screenName,\n                    username: this.client.profile.username,\n                    text: tweetResult.legacy.full_text,\n                    conversationId: tweetResult.legacy.conversation_id_str,\n                    createdAt: tweetResult.legacy.created_at,\n                    timestamp: new Date(\n                        tweetResult.legacy.created_at\n                    ).getTime(),\n                    userId: this.client.profile.id,\n                    inReplyToStatusId:\n                        tweetResult.legacy.in_reply_to_status_id_str,\n                    permanentUrl: `https://twitter.com/${this.twitterUsername}/status/${tweetResult.rest_id}`,\n                    hashtags: [],\n                    mentions: [],\n                    photos: [],\n                    thread: [],\n                    urls: [],\n                    videos: [],\n                } as Tweet;\n\n                await this.runtime.cacheManager.set(\n                    `twitter/${this.client.profile.username}/lastPost`,\n                    {\n                        id: tweet.id,\n                        timestamp: Date.now(),\n                    }\n                );\n\n                await this.client.cacheTweet(tweet);\n\n                elizaLogger.log(`Tweet posted:\\n ${tweet.permanentUrl}`);\n\n                await this.runtime.ensureRoomExists(roomId);\n                await this.runtime.ensureParticipantInRoom(\n                    this.runtime.agentId,\n                    roomId\n                );\n\n                await this.runtime.messageManager.createMemory({\n                    id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                    userId: this.runtime.agentId,\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: newTweetContent.trim(),\n                        url: tweet.permanentUrl,\n                        source: \"twitter\",\n                    },\n                    roomId,\n                    embedding: getEmbeddingZeroVector(),\n                    createdAt: tweet.timestamp,\n                });\n            } catch (error) {\n                elizaLogger.error(\"Error sending tweet:\", error);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error generating new tweet:\", error);\n        }\n    }\n\n    private async generateTweetContent(tweetState: any, options?: {\n        template?: string;\n        context?: string;\n    }): Promise<string> {\n        const context = composeContext({\n            state: tweetState,\n            template: options?.template || this.runtime.character.templates?.twitterPostTemplate || twitterPostTemplate,\n        });\n\n        const response = await generateText({\n            runtime: this.runtime,\n            context: options?.context || context,\n            modelClass: ModelClass.SMALL\n        });\n        console.log(\"generate tweet content response:\\n\" + response);\n\n        // First clean up any markdown and newlines\n        const cleanedResponse = response\n            .replace(/```json\\s*/g, '')  // Remove ```json\n            .replace(/```\\s*/g, '')      // Remove any remaining ```\n            .replaceAll(/\\\\n/g, \"\\n\")\n            .trim();\n\n        // Try to parse as JSON first\n        try {\n            const jsonResponse = JSON.parse(cleanedResponse);\n            if (jsonResponse.text) {\n                return this.trimTweetLength(jsonResponse.text);\n            }\n            if (typeof jsonResponse === 'object') {\n                const possibleContent = jsonResponse.content || jsonResponse.message || jsonResponse.response;\n                if (possibleContent) {\n                    return this.trimTweetLength(possibleContent);\n                }\n            }\n        } catch (error) {\n            error.linted = true; // make linter happy since catch needs a variable\n\n            // If JSON parsing fails, treat as plain text\n            elizaLogger.debug('Response is not JSON, treating as plain text');\n        }\n\n        // If not JSON or no valid content found, clean the raw text\n        return this.trimTweetLength(cleanedResponse);\n    }\n\n    // Helper method to ensure tweet length compliance\n    private trimTweetLength(text: string, maxLength: number = 280): string {\n        if (text.length <= maxLength) return text;\n\n        // Try to cut at last sentence\n        const lastSentence = text.slice(0, maxLength).lastIndexOf('.');\n        if (lastSentence > 0) {\n            return text.slice(0, lastSentence + 1).trim();\n        }\n\n        // Fallback to word boundary\n        return text.slice(0, text.lastIndexOf(' ', maxLength - 3)).trim() + '...';\n    }\n\n    private async processTweetActions() {\n        if (this.isProcessing) {\n            elizaLogger.log('Already processing tweet actions, skipping');\n            return null;\n        }\n\n        try {\n            this.isProcessing = true;\n            this.lastProcessTime = Date.now();\n\n            elizaLogger.log(\"Processing tweet actions\");\n\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                this.twitterUsername,\n                this.runtime.character.name,\n                \"twitter\"\n            );\n\n            const homeTimeline = await this.client.fetchTimelineForActions(15);\n            const results = [];\n\n            for (const tweet of homeTimeline) {\n                try {\n                    // Skip if we've already processed this tweet\n                    const memory = await this.runtime.messageManager.getMemoryById(\n                        stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                    );\n                    if (memory) {\n                        elizaLogger.log(`Already processed tweet ID: ${tweet.id}`);\n                        continue;\n                    }\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const tweetState = await this.runtime.composeState(\n                        {\n                            userId: this.runtime.agentId,\n                            roomId,\n                            agentId: this.runtime.agentId,\n                            content: { text: \"\", action: \"\" },\n                        },\n                        {\n                            twitterUserName: this.twitterUsername,\n                            currentTweet: `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})\\nText: ${tweet.text}`,\n                        }\n                    );\n\n                    const actionContext = composeContext({\n                        state: tweetState,\n                        template: this.runtime.character.templates?.twitterActionTemplate || twitterActionTemplate,\n                    });\n\n                    const actionResponse = await generateTweetActions({\n                        runtime: this.runtime,\n                        context: actionContext,\n                        modelClass: ModelClass.SMALL,\n                    });\n\n                    if (!actionResponse) {\n                        elizaLogger.log(`No valid actions generated for tweet ${tweet.id}`);\n                        continue;\n                    }\n\n                    const executedActions: string[] = [];\n\n                    // Execute actions\n                    if (actionResponse.like) {\n                        try {\n                            await this.client.twitterClient.likeTweet(tweet.id);\n                            executedActions.push('like');\n                            elizaLogger.log(`Liked tweet ${tweet.id}`);\n                        } catch (error) {\n                            elizaLogger.error(`Error liking tweet ${tweet.id}:`, error);\n                        }\n                    }\n\n                    if (actionResponse.retweet) {\n                        try {\n                            await this.client.twitterClient.retweet(tweet.id);\n                            executedActions.push('retweet');\n                            elizaLogger.log(`Retweeted tweet ${tweet.id}`);\n                        } catch (error) {\n                            elizaLogger.error(`Error retweeting tweet ${tweet.id}:`, error);\n                        }\n                    }\n\n                    if (actionResponse.quote) {\n                        try {\n                            // Build conversation thread for context\n                            const thread = await buildConversationThread(tweet, this.client);\n                            const formattedConversation = thread\n                                .map((t) => `@${t.username} (${new Date(t.timestamp * 1000).toLocaleString()}): ${t.text}`)\n                                .join(\"\\n\\n\");\n\n                            // Generate image descriptions if present\n                            const imageDescriptions = [];\n                            if (tweet.photos?.length > 0) {\n                                elizaLogger.log('Processing images in tweet for context');\n                                for (const photo of tweet.photos) {\n                                    const description = await this.runtime\n                                        .getService<IImageDescriptionService>(ServiceType.IMAGE_DESCRIPTION)\n                                        .describeImage(photo.url);\n                                    imageDescriptions.push(description);\n                                }\n                            }\n\n                            // Handle quoted tweet if present\n                            let quotedContent = '';\n                            if (tweet.quotedStatusId) {\n                                try {\n                                    const quotedTweet = await this.client.twitterClient.getTweet(tweet.quotedStatusId);\n                                    if (quotedTweet) {\n                                        quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n                                    }\n                                } catch (error) {\n                                    elizaLogger.error('Error fetching quoted tweet:', error);\n                                }\n                            }\n\n                            // Compose rich state with all context\n                            const enrichedState = await this.runtime.composeState(\n                                {\n                                    userId: this.runtime.agentId,\n                                    roomId: stringToUuid(tweet.conversationId + \"-\" + this.runtime.agentId),\n                                    agentId: this.runtime.agentId,\n                                    content: { text: tweet.text, action: \"QUOTE\" }\n                                },\n                                {\n                                    twitterUserName: this.twitterUsername,\n                                    currentPost: `From @${tweet.username}: ${tweet.text}`,\n                                    formattedConversation,\n                                    imageContext: imageDescriptions.length > 0\n                                        ? `\\nImages in Tweet:\\n${imageDescriptions.map((desc, i) => `Image ${i + 1}: ${desc}`).join('\\n')}`\n                                        : '',\n                                    quotedContent,\n                                }\n                            );\n\n                            const quoteContent = await this.generateTweetContent(enrichedState, {\n                                template: this.runtime.character.templates?.twitterMessageHandlerTemplate || twitterMessageHandlerTemplate\n                            });\n\n                            if (!quoteContent) {\n                                elizaLogger.error('Failed to generate valid quote tweet content');\n                                return;\n                            }\n\n                            elizaLogger.log('Generated quote tweet content:', quoteContent);\n\n                            // Send the tweet through request queue\n                            const result = await this.client.requestQueue.add(\n                                async () => await this.client.twitterClient.sendQuoteTweet(\n                                    quoteContent,\n                                    tweet.id\n                                )\n                            );\n\n                            const body = await result.json();\n\n                            if (body?.data?.create_tweet?.tweet_results?.result) {\n                                elizaLogger.log('Successfully posted quote tweet');\n                                executedActions.push('quote');\n\n                                // Cache generation context for debugging\n                                await this.runtime.cacheManager.set(\n                                    `twitter/quote_generation_${tweet.id}.txt`,\n                                    `Context:\\n${enrichedState}\\n\\nGenerated Quote:\\n${quoteContent}`\n                                );\n                            } else {\n                                elizaLogger.error('Quote tweet creation failed:', body);\n                            }\n                        } catch (error) {\n                            elizaLogger.error('Error in quote tweet generation:', error);\n                        }\n                    }\n\n                    if (actionResponse.reply) {\n                        try {\n                            await this.handleTextOnlyReply(tweet, tweetState, executedActions);\n                        } catch (error) {\n                            elizaLogger.error(`Error replying to tweet ${tweet.id}:`, error);\n                        }\n                    }\n\n                    // Add these checks before creating memory\n                    await this.runtime.ensureRoomExists(roomId);\n                    await this.runtime.ensureUserExists(\n                        stringToUuid(tweet.userId),\n                        tweet.username,\n                        tweet.name,\n                        \"twitter\"\n                    );\n                    await this.runtime.ensureParticipantInRoom(\n                        this.runtime.agentId,\n                        roomId\n                    );\n\n                    // Then create the memory\n                    await this.runtime.messageManager.createMemory({\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                        userId: stringToUuid(tweet.userId),\n                        content: {\n                            text: tweet.text,\n                            url: tweet.permanentUrl,\n                            source: \"twitter\",\n                            action: executedActions.join(\",\"),\n                        },\n                        agentId: this.runtime.agentId,\n                        roomId,\n                        embedding: getEmbeddingZeroVector(),\n                        createdAt: tweet.timestamp * 1000,\n                    });\n\n                    results.push({\n                        tweetId: tweet.id,\n                        parsedActions: actionResponse,\n                        executedActions\n                    });\n\n                } catch (error) {\n                    elizaLogger.error(`Error processing tweet ${tweet.id}:`, error);\n                    continue;\n                }\n            }\n\n            return results; // Return results array to indicate completion\n\n        } catch (error) {\n            elizaLogger.error('Error in processTweetActions:', error);\n            throw error;\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n\n    private async handleTextOnlyReply(tweet: Tweet, tweetState: any, executedActions: string[]) {\n        try {\n            // Build conversation thread for context\n            const thread = await buildConversationThread(tweet, this.client);\n            const formattedConversation = thread\n                .map((t) => `@${t.username} (${new Date(t.timestamp * 1000).toLocaleString()}): ${t.text}`)\n                .join(\"\\n\\n\");\n\n            // Generate image descriptions if present\n            const imageDescriptions = [];\n            if (tweet.photos?.length > 0) {\n                elizaLogger.log('Processing images in tweet for context');\n                for (const photo of tweet.photos) {\n                    const description = await this.runtime\n                        .getService<IImageDescriptionService>(ServiceType.IMAGE_DESCRIPTION)\n                        .describeImage(photo.url);\n                    imageDescriptions.push(description);\n                }\n            }\n\n            // Handle quoted tweet if present\n            let quotedContent = '';\n            if (tweet.quotedStatusId) {\n                try {\n                    const quotedTweet = await this.client.twitterClient.getTweet(tweet.quotedStatusId);\n                    if (quotedTweet) {\n                        quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n                    }\n                } catch (error) {\n                    elizaLogger.error('Error fetching quoted tweet:', error);\n                }\n            }\n\n            // Compose rich state with all context\n            const enrichedState = await this.runtime.composeState(\n                {\n                    userId: this.runtime.agentId,\n                    roomId: stringToUuid(tweet.conversationId + \"-\" + this.runtime.agentId),\n                    agentId: this.runtime.agentId,\n                    content: { text: tweet.text, action: \"\" }\n                },\n                {\n                    twitterUserName: this.twitterUsername,\n                    currentPost: `From @${tweet.username}: ${tweet.text}`,\n                    formattedConversation,\n                    imageContext: imageDescriptions.length > 0\n                        ? `\\nImages in Tweet:\\n${imageDescriptions.map((desc, i) => `Image ${i + 1}: ${desc}`).join('\\n')}`\n                        : '',\n                    quotedContent,\n                }\n            );\n\n            // Generate and clean the reply content\n            const replyText = await this.generateTweetContent(enrichedState, {\n                template: this.runtime.character.templates?.twitterMessageHandlerTemplate || twitterMessageHandlerTemplate\n            });\n\n            if (!replyText) {\n                elizaLogger.error('Failed to generate valid reply content');\n                return;\n            }\n\n            elizaLogger.debug('Final reply text to be sent:', replyText);\n\n            // Send the tweet through request queue\n            const result = await this.client.requestQueue.add(\n                async () => await this.client.twitterClient.sendTweet(\n                    replyText,\n                    tweet.id\n                )\n            );\n\n            const body = await result.json();\n\n            if (body?.data?.create_tweet?.tweet_results?.result) {\n                elizaLogger.log('Successfully posted reply tweet');\n                executedActions.push('reply');\n\n                // Cache generation context for debugging\n                await this.runtime.cacheManager.set(\n                    `twitter/reply_generation_${tweet.id}.txt`,\n                    `Context:\\n${enrichedState}\\n\\nGenerated Reply:\\n${replyText}`\n                );\n            } else {\n                elizaLogger.error('Tweet reply creation failed:', body);\n            }\n        } catch (error) {\n            elizaLogger.error('Error in handleTextOnlyReply:', error);\n        }\n    }\n\n    async stop() {\n        this.stopProcessingActions = true;\n    }\n}\n","import { Tweet } from \"agent-twitter-client\";\nimport { getEmbeddingZeroVector } from \"@ai16z/eliza\";\nimport { Content, Memory, UUID } from \"@ai16z/eliza\";\nimport { stringToUuid } from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base\";\nimport { elizaLogger } from \"@ai16z/eliza\";\nimport { DEFAULT_MAX_TWEET_LENGTH } from \"./environment\";\nimport { Media } from \"@ai16z/eliza\";\nimport fs from \"fs\";\nimport path from \"path\";\n\nexport const wait = (minTime: number = 1000, maxTime: number = 3000) => {\n    const waitTime =\n        Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;\n    return new Promise((resolve) => setTimeout(resolve, waitTime));\n};\n\nexport const isValidTweet = (tweet: Tweet): boolean => {\n    // Filter out tweets with too many hashtags, @s, or $ signs, probably spam or garbage\n    const hashtagCount = (tweet.text?.match(/#/g) || []).length;\n    const atCount = (tweet.text?.match(/@/g) || []).length;\n    const dollarSignCount = (tweet.text?.match(/\\$/g) || []).length;\n    const totalCount = hashtagCount + atCount + dollarSignCount;\n\n    return (\n        hashtagCount <= 1 &&\n        atCount <= 2 &&\n        dollarSignCount <= 1 &&\n        totalCount <= 3\n    );\n};\n\nexport async function buildConversationThread(\n    tweet: Tweet,\n    client: ClientBase,\n    maxReplies: number = 10\n): Promise<Tweet[]> {\n    const thread: Tweet[] = [];\n    const visited: Set<string> = new Set();\n\n    async function processThread(currentTweet: Tweet, depth: number = 0) {\n        elizaLogger.debug(\"Processing tweet:\", {\n            id: currentTweet.id,\n            inReplyToStatusId: currentTweet.inReplyToStatusId,\n            depth: depth,\n        });\n\n        if (!currentTweet) {\n            elizaLogger.debug(\"No current tweet found for thread building\");\n            return;\n        }\n\n        // Stop if we've reached our reply limit\n        if (depth >= maxReplies) {\n            elizaLogger.debug(\"Reached maximum reply depth\", depth);\n            return;\n        }\n\n        // Handle memory storage\n        const memory = await client.runtime.messageManager.getMemoryById(\n            stringToUuid(currentTweet.id + \"-\" + client.runtime.agentId)\n        );\n        if (!memory) {\n            const roomId = stringToUuid(\n                currentTweet.conversationId + \"-\" + client.runtime.agentId\n            );\n            const userId = stringToUuid(currentTweet.userId);\n\n            await client.runtime.ensureConnection(\n                userId,\n                roomId,\n                currentTweet.username,\n                currentTweet.name,\n                \"twitter\"\n            );\n\n            await client.runtime.messageManager.createMemory({\n                id: stringToUuid(\n                    currentTweet.id + \"-\" + client.runtime.agentId\n                ),\n                agentId: client.runtime.agentId,\n                content: {\n                    text: currentTweet.text,\n                    source: \"twitter\",\n                    url: currentTweet.permanentUrl,\n                    inReplyTo: currentTweet.inReplyToStatusId\n                        ? stringToUuid(\n                              currentTweet.inReplyToStatusId +\n                                  \"-\" +\n                                  client.runtime.agentId\n                          )\n                        : undefined,\n                },\n                createdAt: currentTweet.timestamp * 1000,\n                roomId,\n                userId:\n                    currentTweet.userId === client.profile.id\n                        ? client.runtime.agentId\n                        : stringToUuid(currentTweet.userId),\n                embedding: getEmbeddingZeroVector(),\n            });\n        }\n\n        if (visited.has(currentTweet.id)) {\n            elizaLogger.debug(\"Already visited tweet:\", currentTweet.id);\n            return;\n        }\n\n        visited.add(currentTweet.id);\n        thread.unshift(currentTweet);\n\n        elizaLogger.debug(\"Current thread state:\", {\n            length: thread.length,\n            currentDepth: depth,\n            tweetId: currentTweet.id,\n        });\n\n        // If there's a parent tweet, fetch and process it\n        if (currentTweet.inReplyToStatusId) {\n            elizaLogger.debug(\n                \"Fetching parent tweet:\",\n                currentTweet.inReplyToStatusId\n            );\n            try {\n                const parentTweet = await client.twitterClient.getTweet(\n                    currentTweet.inReplyToStatusId\n                );\n\n                if (parentTweet) {\n                    elizaLogger.debug(\"Found parent tweet:\", {\n                        id: parentTweet.id,\n                        text: parentTweet.text?.slice(0, 50),\n                    });\n                    await processThread(parentTweet, depth + 1);\n                } else {\n                    elizaLogger.debug(\n                        \"No parent tweet found for:\",\n                        currentTweet.inReplyToStatusId\n                    );\n                }\n            } catch (error) {\n                elizaLogger.error(\"Error fetching parent tweet:\", {\n                    tweetId: currentTweet.inReplyToStatusId,\n                    error,\n                });\n            }\n        } else {\n            elizaLogger.debug(\n                \"Reached end of reply chain at:\",\n                currentTweet.id\n            );\n        }\n    }\n\n    await processThread(tweet, 0);\n\n    elizaLogger.debug(\"Final thread built:\", {\n        totalTweets: thread.length,\n        tweetIds: thread.map((t) => ({\n            id: t.id,\n            text: t.text?.slice(0, 50),\n        })),\n    });\n\n    return thread;\n}\n\nexport function getMediaType(attachment: Media) {\n    if (attachment.contentType?.startsWith(\"video\")) {\n        return \"video\";\n    } else if (attachment.contentType?.startsWith(\"image\")) {\n        return \"image\";\n    } else {\n        throw new Error(`Unsupported media type`);\n    }\n}\n\nexport async function sendTweet(\n    client: ClientBase,\n    content: Content,\n    roomId: UUID,\n    twitterUsername: string,\n    inReplyTo: string\n): Promise<Memory[]> {\n    const tweetChunks = splitTweetContent(\n        content.text,\n        Number(client.runtime.getSetting(\"MAX_TWEET_LENGTH\")) ||\n            DEFAULT_MAX_TWEET_LENGTH\n    );\n    const sentTweets: Tweet[] = [];\n    let previousTweetId = inReplyTo;\n\n    for (const chunk of tweetChunks) {\n        let mediaData: { data: Buffer; mediaType: string }[] | undefined;\n\n        if (content.attachments && content.attachments.length > 0) {\n            mediaData = await Promise.all(\n                content.attachments.map(async (attachment: Media) => {\n                    if (/^(http|https):\\/\\//.test(attachment.url)) {\n                        // Handle HTTP URLs\n                        const response = await fetch(attachment.url);\n                        if (!response.ok) {\n                            throw new Error(\n                                `Failed to fetch file: ${attachment.url}`\n                            );\n                        }\n                        const mediaBuffer = Buffer.from(\n                            await response.arrayBuffer()\n                        );\n                        const mediaType = getMediaType(attachment);\n                        return { data: mediaBuffer, mediaType };\n                    } else if (fs.existsSync(attachment.url)) {\n                        // Handle local file paths\n                        const mediaBuffer = await fs.promises.readFile(\n                            path.resolve(attachment.url)\n                        );\n                        const mediaType = getMediaType(attachment);\n                        return { data: mediaBuffer, mediaType };\n                    } else {\n                        throw new Error(\n                            `File not found: ${attachment.url}. Make sure the path is correct.`\n                        );\n                    }\n                })\n            );\n        }\n        const result = await client.requestQueue.add(\n            async () =>\n                await client.twitterClient.sendTweet(\n                    chunk.trim(),\n                    previousTweetId,\n                    mediaData\n                )\n        );\n        const body = await result.json();\n\n        // if we have a response\n        if (body?.data?.create_tweet?.tweet_results?.result) {\n            // Parse the response\n            const tweetResult = body.data.create_tweet.tweet_results.result;\n            const finalTweet: Tweet = {\n                id: tweetResult.rest_id,\n                text: tweetResult.legacy.full_text,\n                conversationId: tweetResult.legacy.conversation_id_str,\n                timestamp:\n                    new Date(tweetResult.legacy.created_at).getTime() / 1000,\n                userId: tweetResult.legacy.user_id_str,\n                inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n                permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n                hashtags: [],\n                mentions: [],\n                photos: [],\n                thread: [],\n                urls: [],\n                videos: [],\n            };\n            sentTweets.push(finalTweet);\n            previousTweetId = finalTweet.id;\n        } else {\n            console.error(\"Error sending chunk\", chunk, \"repsonse:\", body);\n        }\n\n        // Wait a bit between tweets to avoid rate limiting issues\n        await wait(1000, 2000);\n    }\n\n    const memories: Memory[] = sentTweets.map((tweet) => ({\n        id: stringToUuid(tweet.id + \"-\" + client.runtime.agentId),\n        agentId: client.runtime.agentId,\n        userId: client.runtime.agentId,\n        content: {\n            text: tweet.text,\n            source: \"twitter\",\n            url: tweet.permanentUrl,\n            inReplyTo: tweet.inReplyToStatusId\n                ? stringToUuid(\n                      tweet.inReplyToStatusId + \"-\" + client.runtime.agentId\n                  )\n                : undefined,\n        },\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n        createdAt: tweet.timestamp * 1000,\n    }));\n\n    return memories;\n}\n\nfunction splitTweetContent(content: string, maxLength: number): string[] {\n    const paragraphs = content.split(\"\\n\\n\").map((p) => p.trim());\n    const tweets: string[] = [];\n    let currentTweet = \"\";\n\n    for (const paragraph of paragraphs) {\n        if (!paragraph) continue;\n\n        if ((currentTweet + \"\\n\\n\" + paragraph).trim().length <= maxLength) {\n            if (currentTweet) {\n                currentTweet += \"\\n\\n\" + paragraph;\n            } else {\n                currentTweet = paragraph;\n            }\n        } else {\n            if (currentTweet) {\n                tweets.push(currentTweet.trim());\n            }\n            if (paragraph.length <= maxLength) {\n                currentTweet = paragraph;\n            } else {\n                // Split long paragraph into smaller chunks\n                const chunks = splitParagraph(paragraph, maxLength);\n                tweets.push(...chunks.slice(0, -1));\n                currentTweet = chunks[chunks.length - 1];\n            }\n        }\n    }\n\n    if (currentTweet) {\n        tweets.push(currentTweet.trim());\n    }\n\n    return tweets;\n}\n\nfunction splitParagraph(paragraph: string, maxLength: number): string[] {\n    // eslint-disable-next-line\n    const sentences = paragraph.match(/[^\\.!\\?]+[\\.!\\?]+|[^\\.!\\?]+$/g) || [\n        paragraph,\n    ];\n    const chunks: string[] = [];\n    let currentChunk = \"\";\n\n    for (const sentence of sentences) {\n        if ((currentChunk + \" \" + sentence).trim().length <= maxLength) {\n            if (currentChunk) {\n                currentChunk += \" \" + sentence;\n            } else {\n                currentChunk = sentence;\n            }\n        } else {\n            if (currentChunk) {\n                chunks.push(currentChunk.trim());\n            }\n            if (sentence.length <= maxLength) {\n                currentChunk = sentence;\n            } else {\n                // Split long sentence into smaller pieces\n                const words = sentence.split(\" \");\n                currentChunk = \"\";\n                for (const word of words) {\n                    if (\n                        (currentChunk + \" \" + word).trim().length <= maxLength\n                    ) {\n                        if (currentChunk) {\n                            currentChunk += \" \" + word;\n                        } else {\n                            currentChunk = word;\n                        }\n                    } else {\n                        if (currentChunk) {\n                            chunks.push(currentChunk.trim());\n                        }\n                        currentChunk = word;\n                    }\n                }\n            }\n        }\n    }\n\n    if (currentChunk) {\n        chunks.push(currentChunk.trim());\n    }\n\n    return chunks;\n}\n","import { IAgentRuntime } from \"@ai16z/eliza\";\nimport { z } from \"zod\";\n\nexport const DEFAULT_MAX_TWEET_LENGTH = 280;\n\nexport const twitterEnvSchema = z.object({\n    TWITTER_DRY_RUN: z\n        .string()\n        .transform((val) => val.toLowerCase() === \"true\"),\n    TWITTER_USERNAME: z.string().min(1, \"Twitter username is required\"),\n    TWITTER_PASSWORD: z.string().min(1, \"Twitter password is required\"),\n    TWITTER_EMAIL: z.string().email(\"Valid Twitter email is required\"),\n    TWITTER_COOKIES: z.string().optional(),\n    MAX_TWEET_LENGTH: z\n        .string()\n        .pipe(z.coerce.number().min(0).int())\n        .default(DEFAULT_MAX_TWEET_LENGTH.toString()),\n});\n\nexport type TwitterConfig = z.infer<typeof twitterEnvSchema>;\n\nexport async function validateTwitterConfig(\n    runtime: IAgentRuntime\n): Promise<TwitterConfig> {\n    try {\n        const twitterConfig = {\n            TWITTER_DRY_RUN:\n                runtime.getSetting(\"TWITTER_DRY_RUN\") ||\n                process.env.TWITTER_DRY_RUN ||\n                \"false\",\n            TWITTER_USERNAME:\n                runtime.getSetting(\"TWITTER_USERNAME\") ||\n                process.env.TWITTER_USERNAME,\n            TWITTER_PASSWORD:\n                runtime.getSetting(\"TWITTER_PASSWORD\") ||\n                process.env.TWITTER_PASSWORD,\n            TWITTER_EMAIL:\n                runtime.getSetting(\"TWITTER_EMAIL\") ||\n                process.env.TWITTER_EMAIL,\n            TWITTER_COOKIES:\n                runtime.getSetting(\"TWITTER_COOKIES\") ||\n                process.env.TWITTER_COOKIES,\n            MAX_TWEET_LENGTH:\n                runtime.getSetting(\"MAX_TWEET_LENGTH\") ||\n                process.env.MAX_TWEET_LENGTH ||\n                DEFAULT_MAX_TWEET_LENGTH.toString(),\n        };\n\n        return twitterEnvSchema.parse(twitterConfig);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Twitter configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import { SearchMode, Tweet } from \"agent-twitter-client\";\nimport {\n    composeContext,\n    generateMessageResponse,\n    generateShouldRespond,\n    messageCompletionFooter,\n    shouldRespondFooter,\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    Memory,\n    ModelClass,\n    State,\n    stringToUuid,\n    elizaLogger,\n    getEmbeddingZeroVector,\n} from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base\";\nimport { buildConversationThread, sendTweet, wait } from \"./utils.ts\";\n\nexport const twitterMessageHandlerTemplate =\n    `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\n{{recentPosts}}\n\n# Task: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\nCurrent Post:\n{{currentPost}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n{{actions}}\n# Task: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}). You MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:\n{{actionNames}}\nHere is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact)\n{{currentPost}}\n` + messageCompletionFooter;\n\nexport const twitterShouldRespondTemplate = (targetUsersStr: string) =>\n    `# INSTRUCTIONS: Determine if {{agentName}} (@{{twitterUserName}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"true\" or \"false\".\n\nResponse options are RESPOND, IGNORE and STOP.\n\nPRIORITY RULE: ALWAYS RESPOND to these users regardless of topic or message content: ${targetUsersStr}. Topic relevance should be ignored for these users.\n\nFor other users:\n- {{agentName}} should RESPOND to messages directed at them\n- {{agentName}} should RESPOND to conversations relevant to their background\n- {{agentName}} should IGNORE irrelevant messages\n- {{agentName}} should IGNORE very short messages unless directly addressed\n- {{agentName}} should STOP if asked to stop\n- {{agentName}} should STOP if conversation is concluded\n- {{agentName}} is in a room with other users and wants to be conversational, but not annoying.\n\n{{recentPosts}}\n\nIMPORTANT: For users not in the priority list, {{agentName}} (@{{twitterUserName}}) should err on the side of IGNORE rather than RESPOND if in doubt.\n\n{{recentPosts}}\n\nIMPORTANT: {{agentName}} (aka @{{twitterUserName}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\n\n{{currentPost}}\n\nThread of Tweets You Are Replying To:\n\n{{formattedConversation}}\n\n# INSTRUCTIONS: Respond with [RESPOND] if {{agentName}} should respond, or [IGNORE] if {{agentName}} should not respond to the last message and [STOP] if {{agentName}} should stop participating in the conversation.\n` + shouldRespondFooter;\n\nexport class TwitterInteractionClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n    }\n\n    async start() {\n        const handleTwitterInteractionsLoop = () => {\n            this.handleTwitterInteractions();\n            setTimeout(\n                handleTwitterInteractionsLoop,\n                Number(\n                    this.runtime.getSetting(\"TWITTER_POLL_INTERVAL\") || 120\n                ) * 1000 // Default to 2 minutes\n            );\n        };\n        handleTwitterInteractionsLoop();\n    }\n\n    async handleTwitterInteractions() {\n        elizaLogger.log(\"Checking Twitter interactions\");\n        // Read from environment variable, fallback to default list if not set\n        const targetUsersStr = this.runtime.getSetting(\"TWITTER_TARGET_USERS\");\n\n        const twitterUsername = this.client.profile.username;\n        try {\n            // Check for mentions\n            const mentionCandidates = (\n                await this.client.fetchSearchTweets(\n                    `@${twitterUsername}`,\n                    20,\n                    SearchMode.Latest\n                )\n            ).tweets;\n\n            elizaLogger.log(\n                \"Completed checking mentioned tweets:\",\n                mentionCandidates.length\n            );\n            let uniqueTweetCandidates = [...mentionCandidates];\n            // Only process target users if configured\n            if (targetUsersStr && targetUsersStr.trim()) {\n                const TARGET_USERS = targetUsersStr\n                    .split(\",\")\n                    .map((u) => u.trim())\n                    .filter((u) => u.length > 0); // Filter out empty strings after split\n\n                elizaLogger.log(\"Processing target users:\", TARGET_USERS);\n\n                if (TARGET_USERS.length > 0) {\n                    // Create a map to store tweets by user\n                    const tweetsByUser = new Map<string, Tweet[]>();\n\n                    // Fetch tweets from all target users\n                    for (const username of TARGET_USERS) {\n                        try {\n                            const userTweets = (\n                                await this.client.twitterClient.fetchSearchTweets(\n                                    `from:${username}`,\n                                    3,\n                                    SearchMode.Latest\n                                )\n                            ).tweets;\n\n                            // Filter for unprocessed, non-reply, recent tweets\n                            const validTweets = userTweets.filter((tweet) => {\n                                const isUnprocessed =\n                                    !this.client.lastCheckedTweetId ||\n                                    parseInt(tweet.id) >\n                                        this.client.lastCheckedTweetId;\n                                const isRecent =\n                                    Date.now() - tweet.timestamp * 1000 <\n                                    2 * 60 * 60 * 1000;\n\n                                elizaLogger.log(`Tweet ${tweet.id} checks:`, {\n                                    isUnprocessed,\n                                    isRecent,\n                                    isReply: tweet.isReply,\n                                    isRetweet: tweet.isRetweet,\n                                });\n\n                                return (\n                                    isUnprocessed &&\n                                    !tweet.isReply &&\n                                    !tweet.isRetweet &&\n                                    isRecent\n                                );\n                            });\n\n                            if (validTweets.length > 0) {\n                                tweetsByUser.set(username, validTweets);\n                                elizaLogger.log(\n                                    `Found ${validTweets.length} valid tweets from ${username}`\n                                );\n                            }\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error fetching tweets for ${username}:`,\n                                error\n                            );\n                            continue;\n                        }\n                    }\n\n                    // Select one tweet from each user that has tweets\n                    const selectedTweets: Tweet[] = [];\n                    for (const [username, tweets] of tweetsByUser) {\n                        if (tweets.length > 0) {\n                            // Randomly select one tweet from this user\n                            const randomTweet =\n                                tweets[\n                                    Math.floor(Math.random() * tweets.length)\n                                ];\n                            selectedTweets.push(randomTweet);\n                            elizaLogger.log(\n                                `Selected tweet from ${username}: ${randomTweet.text?.substring(0, 100)}`\n                            );\n                        }\n                    }\n\n                    // Add selected tweets to candidates\n                    uniqueTweetCandidates = [\n                        ...mentionCandidates,\n                        ...selectedTweets,\n                    ];\n                }\n            } else {\n                elizaLogger.log(\n                    \"No target users configured, processing only mentions\"\n                );\n            }\n\n            // Sort tweet candidates by ID in ascending order\n            uniqueTweetCandidates\n                .sort((a, b) => a.id.localeCompare(b.id))\n                .filter((tweet) => tweet.userId !== this.client.profile.id);\n\n            // for each tweet candidate, handle the tweet\n            for (const tweet of uniqueTweetCandidates) {\n                if (\n                    !this.client.lastCheckedTweetId ||\n                    BigInt(tweet.id) > this.client.lastCheckedTweetId\n                ) {\n                    // Generate the tweetId UUID the same way it's done in handleTweet\n                    const tweetId = stringToUuid(\n                        tweet.id + \"-\" + this.runtime.agentId\n                    );\n\n                    // Check if we've already processed this tweet\n                    const existingResponse =\n                        await this.runtime.messageManager.getMemoryById(\n                            tweetId\n                        );\n\n                    if (existingResponse) {\n                        elizaLogger.log(\n                            `Already responded to tweet ${tweet.id}, skipping`\n                        );\n                        continue;\n                    }\n                    elizaLogger.log(\"New Tweet found\", tweet.permanentUrl);\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const userIdUUID =\n                        tweet.userId === this.client.profile.id\n                            ? this.runtime.agentId\n                            : stringToUuid(tweet.userId!);\n\n                    await this.runtime.ensureConnection(\n                        userIdUUID,\n                        roomId,\n                        tweet.username,\n                        tweet.name,\n                        \"twitter\"\n                    );\n\n                    const thread = await buildConversationThread(\n                        tweet,\n                        this.client\n                    );\n\n                    const message = {\n                        content: { text: tweet.text },\n                        agentId: this.runtime.agentId,\n                        userId: userIdUUID,\n                        roomId,\n                    };\n\n                    await this.handleTweet({\n                        tweet,\n                        message,\n                        thread,\n                    });\n\n                    // Update the last checked tweet ID after processing each tweet\n                    this.client.lastCheckedTweetId = BigInt(tweet.id);\n                }\n            }\n\n            // Save the latest checked tweet ID to the file\n            await this.client.cacheLatestCheckedTweetId();\n\n            elizaLogger.log(\"Finished checking Twitter interactions\");\n        } catch (error) {\n            elizaLogger.error(\"Error handling Twitter interactions:\", error);\n        }\n    }\n\n    private async handleTweet({\n        tweet,\n        message,\n        thread,\n    }: {\n        tweet: Tweet;\n        message: Memory;\n        thread: Tweet[];\n    }) {\n        if (tweet.userId === this.client.profile.id) {\n            // console.log(\"skipping tweet from bot itself\", tweet.id);\n            // Skip processing if the tweet is from the bot itself\n            return;\n        }\n\n        if (!message.content.text) {\n            elizaLogger.log(\"Skipping Tweet with no text\", tweet.id);\n            return { text: \"\", action: \"IGNORE\" };\n        }\n\n        elizaLogger.log(\"Processing Tweet: \", tweet.id);\n        const formatTweet = (tweet: Tweet) => {\n            return `  ID: ${tweet.id}\n  From: ${tweet.name} (@${tweet.username})\n  Text: ${tweet.text}`;\n        };\n        const currentPost = formatTweet(tweet);\n\n        elizaLogger.debug(\"Thread: \", thread);\n        const formattedConversation = thread\n            .map(\n                (tweet) => `@${tweet.username} (${new Date(\n                    tweet.timestamp * 1000\n                ).toLocaleString(\"en-US\", {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                    month: \"short\",\n                    day: \"numeric\",\n                })}):\n        ${tweet.text}`\n            )\n            .join(\"\\n\\n\");\n\n        elizaLogger.debug(\"formattedConversation: \", formattedConversation);\n\n        let state = await this.runtime.composeState(message, {\n            twitterClient: this.client.twitterClient,\n            twitterUserName: this.runtime.getSetting(\"TWITTER_USERNAME\"),\n            currentPost,\n            formattedConversation,\n        });\n\n        // check if the tweet exists, save if it doesn't\n        const tweetId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\n        const tweetExists =\n            await this.runtime.messageManager.getMemoryById(tweetId);\n\n        if (!tweetExists) {\n            elizaLogger.log(\"tweet does not exist, saving\");\n            const userIdUUID = stringToUuid(tweet.userId as string);\n            const roomId = stringToUuid(tweet.conversationId);\n\n            const message = {\n                id: tweetId,\n                agentId: this.runtime.agentId,\n                content: {\n                    text: tweet.text,\n                    url: tweet.permanentUrl,\n                    inReplyTo: tweet.inReplyToStatusId\n                        ? stringToUuid(\n                              tweet.inReplyToStatusId +\n                                  \"-\" +\n                                  this.runtime.agentId\n                          )\n                        : undefined,\n                },\n                userId: userIdUUID,\n                roomId,\n                createdAt: tweet.timestamp * 1000,\n            };\n            this.client.saveRequestMessage(message, state);\n        }\n\n        // 1. Get the raw target users string from settings\n        const targetUsersStr = this.runtime.getSetting(\"TWITTER_TARGET_USERS\");\n\n        // 2. Process the string to get valid usernames\n        const validTargetUsersStr =\n            targetUsersStr && targetUsersStr.trim()\n                ? targetUsersStr\n                      .split(\",\") // Split by commas: \"user1,user2\" -> [\"user1\", \"user2\"]\n                      .map((u) => u.trim()) // Remove whitespace: [\" user1 \", \"user2 \"] -> [\"user1\", \"user2\"]\n                      .filter((u) => u.length > 0)\n                      .join(\",\")\n                : \"\";\n\n        const shouldRespondContext = composeContext({\n            state,\n            template:\n                this.runtime.character.templates?.twitterShouldRespondTemplate?.(\n                    validTargetUsersStr\n                ) ||\n                this.runtime.character?.templates?.shouldRespondTemplate ||\n                twitterShouldRespondTemplate(validTargetUsersStr),\n        });\n\n        const shouldRespond = await generateShouldRespond({\n            runtime: this.runtime,\n            context: shouldRespondContext,\n            modelClass: ModelClass.MEDIUM,\n        });\n\n        // Promise<\"RESPOND\" | \"IGNORE\" | \"STOP\" | null> {\n        if (shouldRespond !== \"RESPOND\") {\n            elizaLogger.log(\"Not responding to message\");\n            return { text: \"Response Decision:\", action: shouldRespond };\n        }\n\n        const context = composeContext({\n            state,\n            template:\n                this.runtime.character.templates\n                    ?.twitterMessageHandlerTemplate ||\n                this.runtime.character?.templates?.messageHandlerTemplate ||\n                twitterMessageHandlerTemplate,\n        });\n\n        elizaLogger.debug(\"Interactions prompt:\\n\" + context);\n\n        const response = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.LARGE,\n        });\n\n        const removeQuotes = (str: string) =>\n            str.replace(/^['\"](.*)['\"]$/, \"$1\");\n\n        const stringId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\n\n        response.inReplyTo = stringId;\n\n        response.text = removeQuotes(response.text);\n\n        if (response.text) {\n            try {\n                const callback: HandlerCallback = async (response: Content) => {\n                    const memories = await sendTweet(\n                        this.client,\n                        response,\n                        message.roomId,\n                        this.runtime.getSetting(\"TWITTER_USERNAME\"),\n                        tweet.id\n                    );\n                    return memories;\n                };\n\n                const responseMessages = await callback(response);\n\n                state = (await this.runtime.updateRecentMessageState(\n                    state\n                )) as State;\n\n                for (const responseMessage of responseMessages) {\n                    if (\n                        responseMessage ===\n                        responseMessages[responseMessages.length - 1]\n                    ) {\n                        responseMessage.content.action = response.action;\n                    } else {\n                        responseMessage.content.action = \"CONTINUE\";\n                    }\n                    await this.runtime.messageManager.createMemory(\n                        responseMessage\n                    );\n                }\n\n                await this.runtime.processActions(\n                    message,\n                    responseMessages,\n                    state,\n                    callback\n                );\n\n                const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`;\n\n                await this.runtime.cacheManager.set(\n                    `twitter/tweet_generation_${tweet.id}.txt`,\n                    responseInfo\n                );\n                await wait();\n            } catch (error) {\n                elizaLogger.error(`Error sending response tweet: ${error}`);\n            }\n        }\n    }\n\n    async buildConversationThread(\n        tweet: Tweet,\n        maxReplies: number = 10\n    ): Promise<Tweet[]> {\n        const thread: Tweet[] = [];\n        const visited: Set<string> = new Set();\n\n        async function processThread(currentTweet: Tweet, depth: number = 0) {\n            elizaLogger.log(\"Processing tweet:\", {\n                id: currentTweet.id,\n                inReplyToStatusId: currentTweet.inReplyToStatusId,\n                depth: depth,\n            });\n\n            if (!currentTweet) {\n                elizaLogger.log(\"No current tweet found for thread building\");\n                return;\n            }\n\n            if (depth >= maxReplies) {\n                elizaLogger.log(\"Reached maximum reply depth\", depth);\n                return;\n            }\n\n            // Handle memory storage\n            const memory = await this.runtime.messageManager.getMemoryById(\n                stringToUuid(currentTweet.id + \"-\" + this.runtime.agentId)\n            );\n            if (!memory) {\n                const roomId = stringToUuid(\n                    currentTweet.conversationId + \"-\" + this.runtime.agentId\n                );\n                const userId = stringToUuid(currentTweet.userId);\n\n                await this.runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    currentTweet.username,\n                    currentTweet.name,\n                    \"twitter\"\n                );\n\n                this.runtime.messageManager.createMemory({\n                    id: stringToUuid(\n                        currentTweet.id + \"-\" + this.runtime.agentId\n                    ),\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: currentTweet.text,\n                        source: \"twitter\",\n                        url: currentTweet.permanentUrl,\n                        inReplyTo: currentTweet.inReplyToStatusId\n                            ? stringToUuid(\n                                  currentTweet.inReplyToStatusId +\n                                      \"-\" +\n                                      this.runtime.agentId\n                              )\n                            : undefined,\n                    },\n                    createdAt: currentTweet.timestamp * 1000,\n                    roomId,\n                    userId:\n                        currentTweet.userId === this.twitterUserId\n                            ? this.runtime.agentId\n                            : stringToUuid(currentTweet.userId),\n                    embedding: getEmbeddingZeroVector(),\n                });\n            }\n\n            if (visited.has(currentTweet.id)) {\n                elizaLogger.log(\"Already visited tweet:\", currentTweet.id);\n                return;\n            }\n\n            visited.add(currentTweet.id);\n            thread.unshift(currentTweet);\n\n            elizaLogger.debug(\"Current thread state:\", {\n                length: thread.length,\n                currentDepth: depth,\n                tweetId: currentTweet.id,\n            });\n\n            if (currentTweet.inReplyToStatusId) {\n                elizaLogger.log(\n                    \"Fetching parent tweet:\",\n                    currentTweet.inReplyToStatusId\n                );\n                try {\n                    const parentTweet = await this.twitterClient.getTweet(\n                        currentTweet.inReplyToStatusId\n                    );\n\n                    if (parentTweet) {\n                        elizaLogger.log(\"Found parent tweet:\", {\n                            id: parentTweet.id,\n                            text: parentTweet.text?.slice(0, 50),\n                        });\n                        await processThread(parentTweet, depth + 1);\n                    } else {\n                        elizaLogger.log(\n                            \"No parent tweet found for:\",\n                            currentTweet.inReplyToStatusId\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.log(\"Error fetching parent tweet:\", {\n                        tweetId: currentTweet.inReplyToStatusId,\n                        error,\n                    });\n                }\n            } else {\n                elizaLogger.log(\n                    \"Reached end of reply chain at:\",\n                    currentTweet.id\n                );\n            }\n        }\n\n        // Need to bind this context for the inner function\n        await processThread.bind(this)(tweet, 0);\n\n        elizaLogger.debug(\"Final thread built:\", {\n            totalTweets: thread.length,\n            tweetIds: thread.map((t) => ({\n                id: t.id,\n                text: t.text?.slice(0, 50),\n            })),\n        });\n\n        return thread;\n    }\n}\n","import { SearchMode } from \"agent-twitter-client\";\nimport { composeContext } from \"@ai16z/eliza\";\nimport { generateMessageResponse, generateText } from \"@ai16z/eliza\";\nimport { messageCompletionFooter } from \"@ai16z/eliza\";\nimport {\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    IImageDescriptionService,\n    ModelClass,\n    ServiceType,\n    State,\n} from \"@ai16z/eliza\";\nimport { stringToUuid } from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base\";\nimport { buildConversationThread, sendTweet, wait } from \"./utils.ts\";\n\nconst twitterSearchTemplate =\n    `{{timeline}}\n\n{{providers}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\nAbout {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{postDirections}}\n\n{{recentPosts}}\n\n# Task: Respond to the following post in the style and perspective of {{agentName}} (aka @{{twitterUserName}}). Write a {{adjective}} response for {{agentName}} to say directly in response to the post. don't generalize.\n{{currentPost}}\n\nIMPORTANT: Your response CANNOT be longer than 20 words.\nAim for 1-2 short sentences maximum. Be concise and direct.\n\nYour response should not contain any questions. Brief, concise statements only. No emojis. Use \\\\n\\\\n (double spaces) between statements.\n\n` + messageCompletionFooter;\n\nexport class TwitterSearchClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    twitterUsername: string;\n    private respondedTweets: Set<string> = new Set();\n\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.twitterUsername = runtime.getSetting(\"TWITTER_USERNAME\");\n    }\n\n    async start() {\n        this.engageWithSearchTermsLoop();\n    }\n\n    private engageWithSearchTermsLoop() {\n        this.engageWithSearchTerms();\n        setTimeout(\n            () => this.engageWithSearchTermsLoop(),\n            (Math.floor(Math.random() * (120 - 60 + 1)) + 60) * 60 * 1000\n        );\n    }\n\n    private async engageWithSearchTerms() {\n        console.log(\"Engaging with search terms\");\n        try {\n            const searchTerm = [...this.runtime.character.topics][\n                Math.floor(Math.random() * this.runtime.character.topics.length)\n            ];\n\n            console.log(\"Fetching search tweets\");\n            // TODO: we wait 5 seconds here to avoid getting rate limited on startup, but we should queue\n            await new Promise((resolve) => setTimeout(resolve, 5000));\n            const recentTweets = await this.client.fetchSearchTweets(\n                searchTerm,\n                20,\n                SearchMode.Top\n            );\n            console.log(\"Search tweets fetched\");\n\n            const homeTimeline = await this.client.fetchHomeTimeline(50);\n\n            await this.client.cacheTimeline(homeTimeline);\n\n            const formattedHomeTimeline =\n                `# ${this.runtime.character.name}'s Home Timeline\\n\\n` +\n                homeTimeline\n                    .map((tweet) => {\n                        return `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : \"\"}\\nText: ${tweet.text}\\n---\\n`;\n                    })\n                    .join(\"\\n\");\n\n            // randomly slice .tweets down to 20\n            const slicedTweets = recentTweets.tweets\n                .sort(() => Math.random() - 0.5)\n                .slice(0, 20);\n\n            if (slicedTweets.length === 0) {\n                console.log(\n                    \"No valid tweets found for the search term\",\n                    searchTerm\n                );\n                return;\n            }\n\n            const prompt = `\n  Here are some tweets related to the search term \"${searchTerm}\":\n\n  ${[...slicedTweets, ...homeTimeline]\n      .filter((tweet) => {\n          // ignore tweets where any of the thread tweets contain a tweet by the bot\n          const thread = tweet.thread;\n          const botTweet = thread.find(\n              (t) => t.username === this.twitterUsername\n          );\n          return !botTweet;\n      })\n      .map(\n          (tweet) => `\n    ID: ${tweet.id}${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : \"\"}\n    From: ${tweet.name} (@${tweet.username})\n    Text: ${tweet.text}\n  `\n      )\n      .join(\"\\n\")}\n\n  Which tweet is the most interesting and relevant for Ruby to reply to? Please provide only the ID of the tweet in your response.\n  Notes:\n    - Respond to English tweets only\n    - Respond to tweets that don't have a lot of hashtags, links, URLs or images\n    - Respond to tweets that are not retweets\n    - Respond to tweets where there is an easy exchange of ideas to have with the user\n    - ONLY respond with the ID of the tweet`;\n\n            const mostInterestingTweetResponse = await generateText({\n                runtime: this.runtime,\n                context: prompt,\n                modelClass: ModelClass.SMALL,\n            });\n\n            const tweetId = mostInterestingTweetResponse.trim();\n            const selectedTweet = slicedTweets.find(\n                (tweet) =>\n                    tweet.id.toString().includes(tweetId) ||\n                    tweetId.includes(tweet.id.toString())\n            );\n\n            if (!selectedTweet) {\n                console.log(\"No matching tweet found for the selected ID\");\n                return console.log(\"Selected tweet ID:\", tweetId);\n            }\n\n            console.log(\"Selected tweet to reply to:\", selectedTweet?.text);\n\n            if (selectedTweet.username === this.twitterUsername) {\n                console.log(\"Skipping tweet from bot itself\");\n                return;\n            }\n\n            const conversationId = selectedTweet.conversationId;\n            const roomId = stringToUuid(\n                conversationId + \"-\" + this.runtime.agentId\n            );\n\n            const userIdUUID = stringToUuid(selectedTweet.userId as string);\n\n            await this.runtime.ensureConnection(\n                userIdUUID,\n                roomId,\n                selectedTweet.username,\n                selectedTweet.name,\n                \"twitter\"\n            );\n\n            // crawl additional conversation tweets, if there are any\n            await buildConversationThread(selectedTweet, this.client);\n\n            const message = {\n                id: stringToUuid(selectedTweet.id + \"-\" + this.runtime.agentId),\n                agentId: this.runtime.agentId,\n                content: {\n                    text: selectedTweet.text,\n                    url: selectedTweet.permanentUrl,\n                    inReplyTo: selectedTweet.inReplyToStatusId\n                        ? stringToUuid(\n                              selectedTweet.inReplyToStatusId +\n                                  \"-\" +\n                                  this.runtime.agentId\n                          )\n                        : undefined,\n                },\n                userId: userIdUUID,\n                roomId,\n                // Timestamps are in seconds, but we need them in milliseconds\n                createdAt: selectedTweet.timestamp * 1000,\n            };\n\n            if (!message.content.text) {\n                return { text: \"\", action: \"IGNORE\" };\n            }\n\n            // Fetch replies and retweets\n            const replies = selectedTweet.thread;\n            const replyContext = replies\n                .filter((reply) => reply.username !== this.twitterUsername)\n                .map((reply) => `@${reply.username}: ${reply.text}`)\n                .join(\"\\n\");\n\n            let tweetBackground = \"\";\n            if (selectedTweet.isRetweet) {\n                const originalTweet = await this.client.requestQueue.add(() =>\n                    this.client.twitterClient.getTweet(selectedTweet.id)\n                );\n                tweetBackground = `Retweeting @${originalTweet.username}: ${originalTweet.text}`;\n            }\n\n            // Generate image descriptions using GPT-4 vision API\n            const imageDescriptions = [];\n            for (const photo of selectedTweet.photos) {\n                const description = await this.runtime\n                    .getService<IImageDescriptionService>(\n                        ServiceType.IMAGE_DESCRIPTION\n                    )\n                    .describeImage(photo.url);\n                imageDescriptions.push(description);\n            }\n\n            let state = await this.runtime.composeState(message, {\n                twitterClient: this.client.twitterClient,\n                twitterUserName: this.twitterUsername,\n                timeline: formattedHomeTimeline,\n                tweetContext: `${tweetBackground}\n\n  Original Post:\n  By @${selectedTweet.username}\n  ${selectedTweet.text}${replyContext.length > 0 && `\\nReplies to original post:\\n${replyContext}`}\n  ${`Original post text: ${selectedTweet.text}`}\n  ${selectedTweet.urls.length > 0 ? `URLs: ${selectedTweet.urls.join(\", \")}\\n` : \"\"}${imageDescriptions.length > 0 ? `\\nImages in Post (Described): ${imageDescriptions.join(\", \")}\\n` : \"\"}\n  `,\n            });\n\n            await this.client.saveRequestMessage(message, state as State);\n\n            const context = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.twitterSearchTemplate ||\n                    twitterSearchTemplate,\n            });\n\n            const responseContent = await generateMessageResponse({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.LARGE,\n            });\n\n            responseContent.inReplyTo = message.id;\n\n            const response = responseContent;\n\n            if (!response.text) {\n                console.log(\"Returning: No response text found\");\n                return;\n            }\n\n            console.log(\n                `Bot would respond to tweet ${selectedTweet.id} with: ${response.text}`\n            );\n            try {\n                const callback: HandlerCallback = async (response: Content) => {\n                    const memories = await sendTweet(\n                        this.client,\n                        response,\n                        message.roomId,\n                        this.twitterUsername,\n                        tweetId\n                    );\n                    return memories;\n                };\n\n                const responseMessages = await callback(responseContent);\n\n                state = await this.runtime.updateRecentMessageState(state);\n\n                for (const responseMessage of responseMessages) {\n                    await this.runtime.messageManager.createMemory(\n                        responseMessage,\n                        false\n                    );\n                }\n\n                state = await this.runtime.updateRecentMessageState(state);\n\n                await this.runtime.evaluate(message, state);\n\n                await this.runtime.processActions(\n                    message,\n                    responseMessages,\n                    state,\n                    callback\n                );\n\n                this.respondedTweets.add(selectedTweet.id);\n                const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${selectedTweet.id} - ${selectedTweet.username}: ${selectedTweet.text}\\nAgent's Output:\\n${response.text}`;\n\n                await this.runtime.cacheManager.set(\n                    `twitter/tweet_generation_${selectedTweet.id}.txt`,\n                    responseInfo\n                );\n\n                await wait();\n            } catch (error) {\n                console.error(`Error sending response post: ${error}`);\n            }\n        } catch (error) {\n            console.error(\"Error engaging with search terms:\", error);\n        }\n    }\n}\n","import { TwitterPostClient } from \"./post.ts\";\nimport { TwitterSearchClient } from \"./search.ts\";\nimport { TwitterInteractionClient } from \"./interactions.ts\";\nimport { IAgentRuntime, Client, elizaLogger } from \"@ai16z/eliza\";\nimport { validateTwitterConfig } from \"./environment.ts\";\nimport { ClientBase } from \"./base.ts\";\n\nclass TwitterManager {\n    client: ClientBase;\n    post: TwitterPostClient;\n    search: TwitterSearchClient;\n    interaction: TwitterInteractionClient;\n    constructor(runtime: IAgentRuntime, enableSearch:boolean) {\n        this.client = new ClientBase(runtime);\n        this.post = new TwitterPostClient(this.client, runtime);\n\n        if (enableSearch) {\n          // this searches topics from character file\n          elizaLogger.warn('Twitter/X client running in a mode that:')\n          elizaLogger.warn('1. violates consent of random users')\n          elizaLogger.warn('2. burns your rate limit')\n          elizaLogger.warn('3. can get your account banned')\n          elizaLogger.warn('use at your own risk')\n          this.search = new TwitterSearchClient(this.client, runtime); // don't start the search client by default\n        }\n        this.interaction = new TwitterInteractionClient(this.client, runtime);\n    }\n}\n\nexport const TwitterClientInterface: Client = {\n\n    async start(runtime: IAgentRuntime) {\n        await validateTwitterConfig(runtime);\n\n        elizaLogger.log(\"Twitter client started\");\n\n        // enableSearch is just set previous to this call\n        // so enableSearch can change over time\n        // and changing it won't stop the SearchClient in the existing instance\n        const manager = new TwitterManager(runtime, this.enableSearch);\n\n        await manager.client.init();\n\n        await manager.post.start();\n\n        await manager.interaction.start();\n\n        //await manager.search.start(); // don't run the search by default\n\n        return manager;\n    },\n    async stop(_runtime: IAgentRuntime) {\n        elizaLogger.warn(\"Twitter client does not support stopping yet\");\n    },\n};\n\nexport default TwitterClientInterface;\n","import {\n    Content,\n    IAgentRuntime,\n    IImageDescriptionService,\n    Memory,\n    State,\n    UUID,\n    getEmbeddingZeroVector,\n    elizaLogger,\n    stringToUuid,\n} from \"@ai16z/eliza\";\nimport {\n    QueryTweetsResponse,\n    Scraper,\n    SearchMode,\n    Tweet,\n} from \"agent-twitter-client\";\nimport { EventEmitter } from \"events\";\n\nexport function extractAnswer(text: string): string {\n    const startIndex = text.indexOf(\"Answer: \") + 8;\n    const endIndex = text.indexOf(\"<|endoftext|>\", 11);\n    return text.slice(startIndex, endIndex);\n}\n\ntype TwitterProfile = {\n    id: string;\n    username: string;\n    screenName: string;\n    bio: string;\n    nicknames: string[];\n};\n\nclass RequestQueue {\n    private queue: (() => Promise<any>)[] = [];\n    private processing: boolean = false;\n\n    async add<T>(request: () => Promise<T>): Promise<T> {\n        return new Promise((resolve, reject) => {\n            this.queue.push(async () => {\n                try {\n                    const result = await request();\n                    resolve(result);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            this.processQueue();\n        });\n    }\n\n    private async processQueue(): Promise<void> {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const request = this.queue.shift()!;\n            try {\n                await request();\n            } catch (error) {\n                console.error(\"Error processing request:\", error);\n                this.queue.unshift(request);\n                await this.exponentialBackoff(this.queue.length);\n            }\n            await this.randomDelay();\n        }\n\n        this.processing = false;\n    }\n\n    private async exponentialBackoff(retryCount: number): Promise<void> {\n        const delay = Math.pow(2, retryCount) * 1000;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n\n    private async randomDelay(): Promise<void> {\n        const delay = Math.floor(Math.random() * 2000) + 1500;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n}\n\nexport class ClientBase extends EventEmitter {\n    static _twitterClients: { [accountIdentifier: string]: Scraper } = {};\n    twitterClient: Scraper;\n    runtime: IAgentRuntime;\n    directions: string;\n    lastCheckedTweetId: bigint | null = null;\n    imageDescriptionService: IImageDescriptionService;\n    temperature: number = 0.5;\n\n    requestQueue: RequestQueue = new RequestQueue();\n\n    profile: TwitterProfile | null;\n\n    async cacheTweet(tweet: Tweet): Promise<void> {\n        if (!tweet) {\n            console.warn(\"Tweet is undefined, skipping cache\");\n            return;\n        }\n\n        this.runtime.cacheManager.set(`twitter/tweets/${tweet.id}`, tweet);\n    }\n\n    async getCachedTweet(tweetId: string): Promise<Tweet | undefined> {\n        const cached = await this.runtime.cacheManager.get<Tweet>(\n            `twitter/tweets/${tweetId}`\n        );\n\n        return cached;\n    }\n\n    async getTweet(tweetId: string): Promise<Tweet> {\n        const cachedTweet = await this.getCachedTweet(tweetId);\n\n        if (cachedTweet) {\n            return cachedTweet;\n        }\n\n        const tweet = await this.requestQueue.add(() =>\n            this.twitterClient.getTweet(tweetId)\n        );\n\n        await this.cacheTweet(tweet);\n        return tweet;\n    }\n\n    callback: (self: ClientBase) => any = null;\n\n    onReady() {\n        throw new Error(\n            \"Not implemented in base class, please call from subclass\"\n        );\n    }\n\n    constructor(runtime: IAgentRuntime) {\n        super();\n        this.runtime = runtime;\n        const username = this.runtime.getSetting(\"TWITTER_USERNAME\");\n        if (ClientBase._twitterClients[username]) {\n            this.twitterClient = ClientBase._twitterClients[username];\n        } else {\n            this.twitterClient = new Scraper();\n            ClientBase._twitterClients[username] = this.twitterClient;\n        }\n\n        this.directions =\n            \"- \" +\n            this.runtime.character.style.all.join(\"\\n- \") +\n            \"- \" +\n            this.runtime.character.style.post.join();\n    }\n\n    async init() {\n        //test\n        const username = this.runtime.getSetting(\"TWITTER_USERNAME\");\n        const password = this.runtime.getSetting(\"TWITTER_PASSWORD\");\n        const email = this.runtime.getSetting(\"TWITTER_EMAIL\");\n        const twitter2faSecret =\n            this.runtime.getSetting(\"TWITTER_2FA_SECRET\") || undefined;\n        const cookies = this.runtime.getSetting(\"TWITTER_COOKIES\");\n\n        if (!username) {\n            throw new Error(\"Twitter username not configured\");\n        }\n        // Check for Twitter cookies\n        if (cookies) {\n            elizaLogger.debug(\"Using cookies from settings\");\n            const cookiesArray = JSON.parse(cookies);\n\n            await this.setCookiesFromArray(cookiesArray);\n        } else {\n            elizaLogger.debug(\"No cookies found in settings\");\n            elizaLogger.debug(\"Checking for cached cookies\");\n            const cachedCookies = await this.getCachedCookies(username);\n            if (cachedCookies) {\n                await this.setCookiesFromArray(cachedCookies);\n            }\n        }\n\n        elizaLogger.log(\"Waiting for Twitter login\");\n        let retries = 5; // Optional: Set a retry limit\n        while (retries > 0) {\n            const cookies = await this.twitterClient.getCookies();\n            if ((await this.twitterClient.isLoggedIn()) && !!cookies) {\n                elizaLogger.info(\"Already logged in.\");\n                await this.cacheCookies(username, cookies);\n                elizaLogger.info(\"Successfully logged in and cookies cached.\");\n                break;\n            }\n\n            try {\n                await this.twitterClient.login(\n                    username,\n                    password,\n                    email,\n                    twitter2faSecret\n                );\n            } catch (error) {\n                elizaLogger.error(`Login attempt failed: ${error.message}`);\n            }\n\n            retries--;\n            elizaLogger.error(\n                `Failed to login to Twitter. Retrying... (${retries} attempts left)`\n            );\n\n            if (retries === 0) {\n                elizaLogger.error(\n                    \"Max retries reached. Exiting login process.\"\n                );\n                throw new Error(\"Twitter login failed after maximum retries.\");\n            }\n\n            await new Promise((resolve) => setTimeout(resolve, 2000));\n        }\n        // Initialize Twitter profile\n        this.profile = await this.fetchProfile(username);\n\n        if (this.profile) {\n            elizaLogger.log(\"Twitter user ID:\", this.profile.id);\n            elizaLogger.log(\n                \"Twitter loaded:\",\n                JSON.stringify(this.profile, null, 10)\n            );\n            // Store profile info for use in responses\n            this.runtime.character.twitterProfile = {\n                id: this.profile.id,\n                username: this.profile.username,\n                screenName: this.profile.screenName,\n                bio: this.profile.bio,\n                nicknames: this.profile.nicknames,\n            };\n        } else {\n            throw new Error(\"Failed to load profile\");\n        }\n\n        await this.loadLatestCheckedTweetId();\n        await this.populateTimeline();\n    }\n\n    async fetchOwnPosts(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching own posts\");\n        const homeTimeline = await this.twitterClient.getUserTweets(\n            this.profile.id,\n            count\n        );\n        return homeTimeline.tweets;\n    }\n\n    async fetchHomeTimeline(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching home timeline\");\n        const homeTimeline = await this.twitterClient.fetchHomeTimeline(\n            count,\n            []\n        );\n\n        elizaLogger.debug(homeTimeline, { depth: Infinity });\n        const processedTimeline = homeTimeline\n            .filter((t) => t.__typename !== \"TweetWithVisibilityResults\") // what's this about?\n            .map((tweet) => {\n                //console.log(\"tweet is\", tweet);\n                const obj = {\n                    id: tweet.id,\n                    name:\n                        tweet.name ?? tweet?.user_results?.result?.legacy.name,\n                    username:\n                        tweet.username ??\n                        tweet.core?.user_results?.result?.legacy.screen_name,\n                    text: tweet.text ?? tweet.legacy?.full_text,\n                    inReplyToStatusId:\n                        tweet.inReplyToStatusId ??\n                        tweet.legacy?.in_reply_to_status_id_str ??\n                        null,\n                    timestamp:\n                        new Date(tweet.legacy?.created_at).getTime() / 1000,\n                    createdAt:\n                        tweet.createdAt ??\n                        tweet.legacy?.created_at ??\n                        tweet.core?.user_results?.result?.legacy.created_at,\n                    userId: tweet.userId ?? tweet.legacy?.user_id_str,\n                    conversationId:\n                        tweet.conversationId ??\n                        tweet.legacy?.conversation_id_str,\n                    permanentUrl: `https://x.com/${tweet.core?.user_results?.result?.legacy?.screen_name}/status/${tweet.rest_id}`,\n                    hashtags: tweet.hashtags ?? tweet.legacy?.entities.hashtags,\n                    mentions:\n                        tweet.mentions ?? tweet.legacy?.entities.user_mentions,\n                    photos:\n                        tweet.photos ??\n                        tweet.legacy?.entities.media?.filter(\n                            (media) => media.type === \"photo\"\n                        ) ??\n                        [],\n                    thread: tweet.thread || [],\n                    urls: tweet.urls ?? tweet.legacy?.entities.urls,\n                    videos:\n                        tweet.videos ??\n                        tweet.legacy?.entities.media?.filter(\n                            (media) => media.type === \"video\"\n                        ) ??\n                        [],\n                };\n                //console.log(\"obj is\", obj);\n                return obj;\n            });\n        //elizaLogger.debug(\"process homeTimeline\", processedTimeline);\n        return processedTimeline;\n    }\n\n    async fetchTimelineForActions(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching timeline for actions\");\n        const homeTimeline = await this.twitterClient.fetchHomeTimeline(\n            count,\n            []\n        );\n\n        return homeTimeline.map((tweet) => ({\n            id: tweet.rest_id,\n            name: tweet.core?.user_results?.result?.legacy?.name,\n            username: tweet.core?.user_results?.result?.legacy?.screen_name,\n            text: tweet.legacy?.full_text,\n            inReplyToStatusId: tweet.legacy?.in_reply_to_status_id_str,\n            timestamp: new Date(tweet.legacy?.created_at).getTime() / 1000,\n            userId: tweet.legacy?.user_id_str,\n            conversationId: tweet.legacy?.conversation_id_str,\n            permanentUrl: `https://twitter.com/${tweet.core?.user_results?.result?.legacy?.screen_name}/status/${tweet.rest_id}`,\n            hashtags: tweet.legacy?.entities?.hashtags || [],\n            mentions: tweet.legacy?.entities?.user_mentions || [],\n            photos:\n                tweet.legacy?.entities?.media?.filter(\n                    (media) => media.type === \"photo\"\n                ) || [],\n            thread: tweet.thread || [],\n            urls: tweet.legacy?.entities?.urls || [],\n            videos:\n                tweet.legacy?.entities?.media?.filter(\n                    (media) => media.type === \"video\"\n                ) || [],\n        }));\n    }\n\n    async fetchSearchTweets(\n        query: string,\n        maxTweets: number,\n        searchMode: SearchMode,\n        cursor?: string\n    ): Promise<QueryTweetsResponse> {\n        try {\n            // Sometimes this fails because we are rate limited. in this case, we just need to return an empty array\n            // if we dont get a response in 5 seconds, something is wrong\n            const timeoutPromise = new Promise((resolve) =>\n                setTimeout(() => resolve({ tweets: [] }), 10000)\n            );\n\n            try {\n                const result = await this.requestQueue.add(\n                    async () =>\n                        await Promise.race([\n                            this.twitterClient.fetchSearchTweets(\n                                query,\n                                maxTweets,\n                                searchMode,\n                                cursor\n                            ),\n                            timeoutPromise,\n                        ])\n                );\n                return (result ?? { tweets: [] }) as QueryTweetsResponse;\n            } catch (error) {\n                elizaLogger.error(\"Error fetching search tweets:\", error);\n                return { tweets: [] };\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error fetching search tweets:\", error);\n            return { tweets: [] };\n        }\n    }\n\n    private async populateTimeline() {\n        elizaLogger.debug(\"populating timeline...\");\n\n        const cachedTimeline = await this.getCachedTimeline();\n\n        // Check if the cache file exists\n        if (cachedTimeline) {\n            // Read the cached search results from the file\n\n            // Get the existing memories from the database\n            const existingMemories =\n                await this.runtime.messageManager.getMemoriesByRoomIds({\n                    roomIds: cachedTimeline.map((tweet) =>\n                        stringToUuid(\n                            tweet.conversationId + \"-\" + this.runtime.agentId\n                        )\n                    ),\n                });\n\n            //TODO: load tweets not in cache?\n\n            // Create a Set to store the IDs of existing memories\n            const existingMemoryIds = new Set(\n                existingMemories.map((memory) => memory.id.toString())\n            );\n\n            // Check if any of the cached tweets exist in the existing memories\n            const someCachedTweetsExist = cachedTimeline.some((tweet) =>\n                existingMemoryIds.has(\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                )\n            );\n\n            if (someCachedTweetsExist) {\n                // Filter out the cached tweets that already exist in the database\n                const tweetsToSave = cachedTimeline.filter(\n                    (tweet) =>\n                        !existingMemoryIds.has(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        )\n                );\n\n                console.log({\n                    processingTweets: tweetsToSave\n                        .map((tweet) => tweet.id)\n                        .join(\",\"),\n                });\n\n                // Save the missing tweets as memories\n                for (const tweet of tweetsToSave) {\n                    elizaLogger.log(\"Saving Tweet\", tweet.id);\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const userId =\n                        tweet.userId === this.profile.id\n                            ? this.runtime.agentId\n                            : stringToUuid(tweet.userId);\n\n                    if (tweet.userId === this.profile.id) {\n                        await this.runtime.ensureConnection(\n                            this.runtime.agentId,\n                            roomId,\n                            this.profile.username,\n                            this.profile.screenName,\n                            \"twitter\"\n                        );\n                    } else {\n                        await this.runtime.ensureConnection(\n                            userId,\n                            roomId,\n                            tweet.username,\n                            tweet.name,\n                            \"twitter\"\n                        );\n                    }\n\n                    const content = {\n                        text: tweet.text,\n                        url: tweet.permanentUrl,\n                        source: \"twitter\",\n                        inReplyTo: tweet.inReplyToStatusId\n                            ? stringToUuid(\n                                  tweet.inReplyToStatusId +\n                                      \"-\" +\n                                      this.runtime.agentId\n                              )\n                            : undefined,\n                    } as Content;\n\n                    elizaLogger.log(\"Creating memory for tweet\", tweet.id);\n\n                    // check if it already exists\n                    const memory =\n                        await this.runtime.messageManager.getMemoryById(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        );\n\n                    if (memory) {\n                        elizaLogger.log(\n                            \"Memory already exists, skipping timeline population\"\n                        );\n                        break;\n                    }\n\n                    await this.runtime.messageManager.createMemory({\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                        userId,\n                        content: content,\n                        agentId: this.runtime.agentId,\n                        roomId,\n                        embedding: getEmbeddingZeroVector(),\n                        createdAt: tweet.timestamp * 1000,\n                    });\n\n                    await this.cacheTweet(tweet);\n                }\n\n                elizaLogger.log(\n                    `Populated ${tweetsToSave.length} missing tweets from the cache.`\n                );\n                return;\n            }\n        }\n\n        const timeline = await this.fetchHomeTimeline(cachedTimeline ? 10 : 50);\n        const username = this.runtime.getSetting(\"TWITTER_USERNAME\");\n\n        // Get the most recent 20 mentions and interactions\n        const mentionsAndInteractions = await this.fetchSearchTweets(\n            `@${username}`,\n            20,\n            SearchMode.Latest\n        );\n\n        // Combine the timeline tweets and mentions/interactions\n        const allTweets = [...timeline, ...mentionsAndInteractions.tweets];\n\n        // Create a Set to store unique tweet IDs\n        const tweetIdsToCheck = new Set<string>();\n        const roomIds = new Set<UUID>();\n\n        // Add tweet IDs to the Set\n        for (const tweet of allTweets) {\n            tweetIdsToCheck.add(tweet.id);\n            roomIds.add(\n                stringToUuid(tweet.conversationId + \"-\" + this.runtime.agentId)\n            );\n        }\n\n        // Check the existing memories in the database\n        const existingMemories =\n            await this.runtime.messageManager.getMemoriesByRoomIds({\n                roomIds: Array.from(roomIds),\n            });\n\n        // Create a Set to store the existing memory IDs\n        const existingMemoryIds = new Set<UUID>(\n            existingMemories.map((memory) => memory.id)\n        );\n\n        // Filter out the tweets that already exist in the database\n        const tweetsToSave = allTweets.filter(\n            (tweet) =>\n                !existingMemoryIds.has(\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                )\n        );\n\n        elizaLogger.debug({\n            processingTweets: tweetsToSave.map((tweet) => tweet.id).join(\",\"),\n        });\n\n        await this.runtime.ensureUserExists(\n            this.runtime.agentId,\n            this.profile.username,\n            this.runtime.character.name,\n            \"twitter\"\n        );\n\n        // Save the new tweets as memories\n        for (const tweet of tweetsToSave) {\n            elizaLogger.log(\"Saving Tweet\", tweet.id);\n\n            const roomId = stringToUuid(\n                tweet.conversationId + \"-\" + this.runtime.agentId\n            );\n            const userId =\n                tweet.userId === this.profile.id\n                    ? this.runtime.agentId\n                    : stringToUuid(tweet.userId);\n\n            if (tweet.userId === this.profile.id) {\n                await this.runtime.ensureConnection(\n                    this.runtime.agentId,\n                    roomId,\n                    this.profile.username,\n                    this.profile.screenName,\n                    \"twitter\"\n                );\n            } else {\n                await this.runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    tweet.username,\n                    tweet.name,\n                    \"twitter\"\n                );\n            }\n\n            const content = {\n                text: tweet.text,\n                url: tweet.permanentUrl,\n                source: \"twitter\",\n                inReplyTo: tweet.inReplyToStatusId\n                    ? stringToUuid(tweet.inReplyToStatusId)\n                    : undefined,\n            } as Content;\n\n            await this.runtime.messageManager.createMemory({\n                id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                userId,\n                content: content,\n                agentId: this.runtime.agentId,\n                roomId,\n                embedding: getEmbeddingZeroVector(),\n                createdAt: tweet.timestamp * 1000,\n            });\n\n            await this.cacheTweet(tweet);\n        }\n\n        // Cache\n        await this.cacheTimeline(timeline);\n        await this.cacheMentions(mentionsAndInteractions.tweets);\n    }\n\n    async setCookiesFromArray(cookiesArray: any[]) {\n        const cookieStrings = cookiesArray.map(\n            (cookie) =>\n                `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${cookie.path}; ${\n                    cookie.secure ? \"Secure\" : \"\"\n                }; ${cookie.httpOnly ? \"HttpOnly\" : \"\"}; SameSite=${\n                    cookie.sameSite || \"Lax\"\n                }`\n        );\n        await this.twitterClient.setCookies(cookieStrings);\n    }\n\n    async saveRequestMessage(message: Memory, state: State) {\n        if (message.content.text) {\n            const recentMessage = await this.runtime.messageManager.getMemories(\n                {\n                    roomId: message.roomId,\n                    count: 1,\n                    unique: false,\n                }\n            );\n\n            if (\n                recentMessage.length > 0 &&\n                recentMessage[0].content === message.content\n            ) {\n                elizaLogger.debug(\"Message already saved\", recentMessage[0].id);\n            } else {\n                await this.runtime.messageManager.createMemory({\n                    ...message,\n                    embedding: getEmbeddingZeroVector(),\n                });\n            }\n\n            await this.runtime.evaluate(message, {\n                ...state,\n                twitterClient: this.twitterClient,\n            });\n        }\n    }\n\n    async loadLatestCheckedTweetId(): Promise<void> {\n        const latestCheckedTweetId =\n            await this.runtime.cacheManager.get<string>(\n                `twitter/${this.profile.username}/latest_checked_tweet_id`\n            );\n\n        if (latestCheckedTweetId) {\n            this.lastCheckedTweetId = BigInt(latestCheckedTweetId);\n        }\n    }\n\n    async cacheLatestCheckedTweetId() {\n        if (this.lastCheckedTweetId) {\n            await this.runtime.cacheManager.set(\n                `twitter/${this.profile.username}/latest_checked_tweet_id`,\n                this.lastCheckedTweetId.toString()\n            );\n        }\n    }\n\n    async getCachedTimeline(): Promise<Tweet[] | undefined> {\n        return await this.runtime.cacheManager.get<Tweet[]>(\n            `twitter/${this.profile.username}/timeline`\n        );\n    }\n\n    async cacheTimeline(timeline: Tweet[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${this.profile.username}/timeline`,\n            timeline,\n            { expires: Date.now() + 10 * 1000 }\n        );\n    }\n\n    async cacheMentions(mentions: Tweet[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${this.profile.username}/mentions`,\n            mentions,\n            { expires: Date.now() + 10 * 1000 }\n        );\n    }\n\n    async getCachedCookies(username: string) {\n        return await this.runtime.cacheManager.get<any[]>(\n            `twitter/${username}/cookies`\n        );\n    }\n\n    async cacheCookies(username: string, cookies: any[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${username}/cookies`,\n            cookies\n        );\n    }\n\n    async getCachedProfile(username: string) {\n        return await this.runtime.cacheManager.get<TwitterProfile>(\n            `twitter/${username}/profile`\n        );\n    }\n\n    async cacheProfile(profile: TwitterProfile) {\n        await this.runtime.cacheManager.set(\n            `twitter/${profile.username}/profile`,\n            profile\n        );\n    }\n\n    async fetchProfile(username: string): Promise<TwitterProfile> {\n        const cached = await this.getCachedProfile(username);\n\n        if (cached) return cached;\n\n        try {\n            const profile = await this.requestQueue.add(async () => {\n                const profile = await this.twitterClient.getProfile(username);\n                // console.log({ profile });\n                return {\n                    id: profile.userId,\n                    username,\n                    screenName: profile.name || this.runtime.character.name,\n                    bio:\n                        profile.biography ||\n                        typeof this.runtime.character.bio === \"string\"\n                            ? (this.runtime.character.bio as string)\n                            : this.runtime.character.bio.length > 0\n                              ? this.runtime.character.bio[0]\n                              : \"\",\n                    nicknames:\n                        this.runtime.character.twitterProfile?.nicknames || [],\n                } satisfies TwitterProfile;\n            });\n\n            this.cacheProfile(profile);\n\n            return profile;\n        } catch (error) {\n            console.error(\"Error fetching Twitter profile:\", error);\n\n            return undefined;\n        }\n    }\n}\n"],"mappings":"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","names":["composeContext","getEmbeddingZeroVector","ModelClass","stringToUuid","elizaLogger","stringToUuid","elizaLogger","getEmbeddingZeroVector","elizaLogger","stringToUuid","tweet","message","response","getEmbeddingZeroVector","elizaLogger","stringToUuid","composeContext","ModelClass","getEmbeddingZeroVector","SearchMode","composeContext","generateMessageResponse","generateText","messageCompletionFooter","ModelClass","ServiceType","stringToUuid","messageCompletionFooter","SearchMode","generateText","ModelClass","stringToUuid","ServiceType","composeContext","generateMessageResponse","response","elizaLogger","getEmbeddingZeroVector","elizaLogger","stringToUuid","SearchMode","elizaLogger","cookies","existingMemories","stringToUuid","existingMemoryIds","tweetsToSave","getEmbeddingZeroVector","SearchMode","profile","elizaLogger"]}